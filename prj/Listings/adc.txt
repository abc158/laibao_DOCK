; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\adc.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\driver\inc -I.\src -I.\User -I.\User\led -I.\User\usart -I.\User\timer -I.\User\ir -I.\User\2.4G -I.\User\spi0 -IF:\1708\dock\prj\RTE -I"D:\Program Files (x86)\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM0\Include" -I"D:\Program Files (x86)\Keil_v5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DARMCM0 -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\adc.crf ..\driver\src\adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;30      ************************************************************************************************************/
;;;31     void ADC_DeInit( )
000000  b510              PUSH     {r4,lr}
;;;32     {
;;;33       RSTCU_APBPerip0Reset(RSTCU_APBRST0_ADC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0608              LSLS     r0,r1,#24
000006  f7fffffe          BL       RSTCU_APBPerip0Reset
;;;34     }
00000a  bd10              POP      {r4,pc}
;;;35     
                          ENDP

                  ADC_Reset PROC
;;;40      ************************************************************************************************************/
;;;41     void ADC_Reset( )
00000c  489f              LDR      r0,|L1.652|
;;;42     {
;;;43     	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
;;;44     	
;;;45       pAM_ADC->CTL |= ADC_SOFTWARE_RESET;
00000e  6801              LDR      r1,[r0,#0]
000010  2201              MOVS     r2,#1
000012  4311              ORRS     r1,r1,r2
000014  6001              STR      r1,[r0,#0]
;;;46     }
000016  4770              BX       lr
;;;47     
                          ENDP

                  ADC_RegularGroupConfig PROC
;;;58      ************************************************************************************************************/
;;;59     void ADC_RegularGroupConfig(u8 ADC_MODE, u8 Length, u8 SubLength)
000018  b530              PUSH     {r4,r5,lr}
;;;60     {
;;;61     	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
00001a  4b9c              LDR      r3,|L1.652|
;;;62     
;;;63       /* Config cyclic conversion mode and length of list queue and sub length for regular group */
;;;64       pAM_ADC->CONV =  ((u32)(SubLength - 1) << 16) | ((u32)(Length - 1) << 8) | ADC_MODE;
00001c  1e54              SUBS     r4,r2,#1
00001e  0424              LSLS     r4,r4,#16
000020  1e4d              SUBS     r5,r1,#1
000022  022d              LSLS     r5,r5,#8
000024  432c              ORRS     r4,r4,r5
000026  4304              ORRS     r4,r4,r0
000028  605c              STR      r4,[r3,#4]
;;;65     }
00002a  bd30              POP      {r4,r5,pc}
;;;66     
                          ENDP

                  ADC_HPGroupConfig PROC
;;;78      ************************************************************************************************************/
;;;79     void ADC_HPGroupConfig(u8 ADC_MODE, u8 Length, u8 SubLength)
00002c  b530              PUSH     {r4,r5,lr}
;;;80     {
;;;81     	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
00002e  4b97              LDR      r3,|L1.652|
;;;82     	
;;;83       /* Config cyclic conversion mode and length of list queue and sub length for regular group */
;;;84       pAM_ADC->HCONV =  ((u32)(SubLength - 1) << 16) | ((u32)(Length - 1) << 8) | ADC_MODE;
000030  1e54              SUBS     r4,r2,#1
000032  0424              LSLS     r4,r4,#16
000034  1e4d              SUBS     r5,r1,#1
000036  022d              LSLS     r5,r5,#8
000038  432c              ORRS     r4,r4,r5
00003a  4304              ORRS     r4,r4,r0
00003c  609c              STR      r4,[r3,#8]
;;;85     }
00003e  bd30              POP      {r4,r5,pc}
;;;86     
                          ENDP

                  ADC_RegularChannelConfig PROC
;;;99      ************************************************************************************************************/
;;;100    void ADC_RegularChannelConfig(u8 ADC_Channel, u8 Rank, u8 SampleClock)
000040  b5f0              PUSH     {r4-r7,lr}
;;;101    {
000042  4603              MOV      r3,r0
;;;102    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
000044  4891              LDR      r0,|L1.652|
;;;103      u32 tmpreg1, tmpreg2;
;;;104    
;;;105      /* config sampling clock of correspond ADC input channel */
;;;106    	if(ADC_Channel<16)
000046  2b10              CMP      r3,#0x10
000048  da07              BGE      |L1.90|
;;;107    		pAM_ADC->CTL = ((pAM_ADC->CTL)&(~(0xff<<8)))|(SampleClock<<8);
00004a  6806              LDR      r6,[r0,#0]
00004c  27ff              MOVS     r7,#0xff
00004e  023f              LSLS     r7,r7,#8
000050  43be              BICS     r6,r6,r7
000052  0217              LSLS     r7,r2,#8
000054  433e              ORRS     r6,r6,r7
000056  6006              STR      r6,[r0,#0]
000058  e006              B        |L1.104|
                  |L1.90|
;;;108    	else
;;;109    		pAM_ADC->CTL = ((pAM_ADC->CTL)&(~(0xff<<16)))|(SampleClock<<16);
00005a  6806              LDR      r6,[r0,#0]
00005c  27ff              MOVS     r7,#0xff
00005e  043f              LSLS     r7,r7,#16
000060  43be              BICS     r6,r6,r7
000062  0417              LSLS     r7,r2,#16
000064  433e              ORRS     r6,r6,r7
000066  6006              STR      r6,[r0,#0]
                  |L1.104|
;;;110    
;;;111      /* Config ADC Rank */
;;;112    
;;;113      /* Get the old register value */
;;;114      tmpreg1 = pAM_ADC->LST[Rank >> 2];
000068  108e              ASRS     r6,r1,#2
00006a  00b6              LSLS     r6,r6,#2
00006c  4607              MOV      r7,r0
00006e  370c              ADDS     r7,r7,#0xc
000070  59bc              LDR      r4,[r7,r6]
;;;115      /* Calculate the mask to clear */
;;;116      tmpreg2 = LST_SEQ_SET << (8 * (Rank & 0x3));
000072  078e              LSLS     r6,r1,#30
000074  0ef7              LSRS     r7,r6,#27
000076  261f              MOVS     r6,#0x1f
000078  40be              LSLS     r6,r6,r7
00007a  4635              MOV      r5,r6
;;;117      /* Clear the old SEQx bits for the selected rank */
;;;118      tmpreg1 &= ~tmpreg2;
00007c  4626              MOV      r6,r4
00007e  43ae              BICS     r6,r6,r5
000080  4634              MOV      r4,r6
;;;119      /* Calculate the mask to set */
;;;120      tmpreg2 = (u32)ADC_Channel << (8 * (Rank & 0x3));
000082  078e              LSLS     r6,r1,#30
000084  0ef6              LSRS     r6,r6,#27
000086  461f              MOV      r7,r3
000088  40b7              LSLS     r7,r7,r6
00008a  463d              MOV      r5,r7
;;;121      /* Set the SEQx bits for the selected rank */
;;;122      tmpreg1 |= tmpreg2;
00008c  4626              MOV      r6,r4
00008e  432e              ORRS     r6,r6,r5
000090  4634              MOV      r4,r6
;;;123      /* Store the new register value */
;;;124      pAM_ADC->LST[Rank >> 2] = tmpreg1;
000092  108e              ASRS     r6,r1,#2
000094  00b7              LSLS     r7,r6,#2
000096  4606              MOV      r6,r0
000098  360c              ADDS     r6,r6,#0xc
00009a  51f4              STR      r4,[r6,r7]
;;;125    }
00009c  bdf0              POP      {r4-r7,pc}
;;;126    
                          ENDP

                  ADC_HPChannelConfig PROC
;;;137     ************************************************************************************************************/
;;;138    void ADC_HPChannelConfig(u8 ADC_Channel, u8 Rank, u8 SampleClock)
00009e  b5f0              PUSH     {r4-r7,lr}
;;;139    {
0000a0  4603              MOV      r3,r0
0000a2  4614              MOV      r4,r2
;;;140    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
0000a4  4879              LDR      r0,|L1.652|
;;;141      u32 tmpreg1, tmpreg2;
;;;142    
;;;143      /* config sampling clock of correspond ADC input channel */
;;;144    	pAM_ADC->CTL = ((pAM_ADC->CTL)&(~(0xff<<8)))|(SampleClock<<8);
0000a6  6806              LDR      r6,[r0,#0]
0000a8  27ff              MOVS     r7,#0xff
0000aa  023f              LSLS     r7,r7,#8
0000ac  43be              BICS     r6,r6,r7
0000ae  0227              LSLS     r7,r4,#8
0000b0  433e              ORRS     r6,r6,r7
0000b2  6006              STR      r6,[r0,#0]
;;;145    
;;;146      /* Config ADC Rank */
;;;147    
;;;148      /* Get the old register value */
;;;149      tmpreg1 = pAM_ADC->HLST;
0000b4  6a02              LDR      r2,[r0,#0x20]
;;;150      /* Calculate the mask to clear */
;;;151      tmpreg2 = HLST_SEQ_SET << (8 * (Rank & 0x3));
0000b6  078e              LSLS     r6,r1,#30
0000b8  0ef7              LSRS     r7,r6,#27
0000ba  261f              MOVS     r6,#0x1f
0000bc  40be              LSLS     r6,r6,r7
0000be  4635              MOV      r5,r6
;;;152      /* Clear the old SEQx bits for the selected rank */
;;;153      tmpreg1 &= ~tmpreg2;
0000c0  4616              MOV      r6,r2
0000c2  43ae              BICS     r6,r6,r5
0000c4  4632              MOV      r2,r6
;;;154      /* Calculate the mask to set */
;;;155      tmpreg2 = (u32)ADC_Channel << (8 * (Rank & 0x3));
0000c6  078e              LSLS     r6,r1,#30
0000c8  0ef6              LSRS     r6,r6,#27
0000ca  461f              MOV      r7,r3
0000cc  40b7              LSLS     r7,r7,r6
0000ce  463d              MOV      r5,r7
;;;156      /* Set the SEQx bits for the selected rank */
;;;157      tmpreg1 |= tmpreg2;
0000d0  4616              MOV      r6,r2
0000d2  432e              ORRS     r6,r6,r5
0000d4  4632              MOV      r2,r6
;;;158      /* Store the new register value */
;;;159      pAM_ADC->HLST = tmpreg1;
0000d6  6202              STR      r2,[r0,#0x20]
;;;160    }
0000d8  bdf0              POP      {r4-r7,pc}
;;;161    
                          ENDP

                  ADC_RegularTrigConfig PROC
;;;174     ************************************************************************************************************/
;;;175    void ADC_RegularTrigConfig(u32 ADC_RegularTrigCtrl)
0000da  496c              LDR      r1,|L1.652|
;;;176    {
;;;177    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
;;;178    	
;;;179      /* Config external trigger conversion source of regular group */
;;;180      pAM_ADC->TCR = (ADC_RegularTrigCtrl >> 28);
0000dc  0f02              LSRS     r2,r0,#28
0000de  67ca              STR      r2,[r1,#0x7c]
;;;181      pAM_ADC->TSR = ADC_RegularTrigCtrl;
0000e0  2280              MOVS     r2,#0x80
0000e2  5050              STR      r0,[r2,r1]
;;;182    }
0000e4  4770              BX       lr
;;;183    
                          ENDP

                  ADC_HPTrigConfig PROC
;;;196     ************************************************************************************************************/
;;;197    void ADC_HPTrigConfig(u32 ADC_HPTrigCtrl)
0000e6  4969              LDR      r1,|L1.652|
;;;198    {
;;;199    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
;;;200    	
;;;201      /* Config external trigger conversion source of regular group */
;;;202      pAM_ADC->HTCR = (ADC_HPTrigCtrl >> 28);
0000e8  0f03              LSRS     r3,r0,#28
0000ea  2284              MOVS     r2,#0x84
0000ec  5053              STR      r3,[r2,r1]
;;;203      pAM_ADC->HTSR = ADC_HPTrigCtrl;
0000ee  2288              MOVS     r2,#0x88
0000f0  5050              STR      r0,[r2,r1]
;;;204    }
0000f2  4770              BX       lr
;;;205    
                          ENDP

                  ADC_SoftwareStartConvCmd PROC
;;;211     ************************************************************************************************************/
;;;212    void ADC_SoftwareStartConvCmd(ControlStatus NewState)
0000f4  4601              MOV      r1,r0
;;;213    {
;;;214    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
0000f6  4865              LDR      r0,|L1.652|
;;;215    
;;;216      /* Start Conversion */
;;;217      if (NewState != DISABLE)
0000f8  2900              CMP      r1,#0
0000fa  d006              BEQ      |L1.266|
;;;218      {
;;;219        pAM_ADC->TSR |= TCR_SC_SET;
0000fc  2280              MOVS     r2,#0x80
0000fe  5812              LDR      r2,[r2,r0]
000100  2301              MOVS     r3,#1
000102  431a              ORRS     r2,r2,r3
000104  2380              MOVS     r3,#0x80
000106  501a              STR      r2,[r3,r0]
000108  e005              B        |L1.278|
                  |L1.266|
;;;220      }
;;;221      else
;;;222      {
;;;223        pAM_ADC->TSR &= ~TCR_SC_SET;
00010a  2280              MOVS     r2,#0x80
00010c  5812              LDR      r2,[r2,r0]
00010e  0853              LSRS     r3,r2,#1
000110  005b              LSLS     r3,r3,#1
000112  2280              MOVS     r2,#0x80
000114  5013              STR      r3,[r2,r0]
                  |L1.278|
;;;224      }
;;;225    }
000116  4770              BX       lr
;;;226    
                          ENDP

                  ADC_HPSoftwareStartConvCmd PROC
;;;232     ************************************************************************************************************/
;;;233    void ADC_HPSoftwareStartConvCmd(ControlStatus NewState)
000118  4601              MOV      r1,r0
;;;234    {
;;;235    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
00011a  485c              LDR      r0,|L1.652|
;;;236    
;;;237      /* Start Conversion */
;;;238      if (NewState != DISABLE)
00011c  2900              CMP      r1,#0
00011e  d006              BEQ      |L1.302|
;;;239      {
;;;240        pAM_ADC->HTSR |= HTCR_SC_SET;
000120  2288              MOVS     r2,#0x88
000122  5812              LDR      r2,[r2,r0]
000124  2301              MOVS     r3,#1
000126  431a              ORRS     r2,r2,r3
000128  2388              MOVS     r3,#0x88
00012a  501a              STR      r2,[r3,r0]
00012c  e005              B        |L1.314|
                  |L1.302|
;;;241      }
;;;242      else
;;;243      {
;;;244        pAM_ADC->HTSR &= ~HTCR_SC_SET;
00012e  2288              MOVS     r2,#0x88
000130  5812              LDR      r2,[r2,r0]
000132  0853              LSRS     r3,r2,#1
000134  005b              LSLS     r3,r3,#1
000136  2288              MOVS     r2,#0x88
000138  5013              STR      r3,[r2,r0]
                  |L1.314|
;;;245      }
;;;246    }
00013a  4770              BX       lr
;;;247    
                          ENDP

                  ADC_GetConversionData PROC
;;;252     ************************************************************************************************************/
;;;253    FlagStatus ADC_GetConversionData(u8 ADC_REGULAR_DATAx, u16 *adc_data)
00013c  b530              PUSH     {r4,r5,lr}
;;;254    {
00013e  4602              MOV      r2,r0
;;;255    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
000140  4c52              LDR      r4,|L1.652|
;;;256    	u32 reg_val;
;;;257    
;;;258    	reg_val = pAM_ADC->DR[ADC_REGULAR_DATAx];
000142  0095              LSLS     r5,r2,#2
000144  4620              MOV      r0,r4
000146  3024              ADDS     r0,r0,#0x24
000148  5943              LDR      r3,[r0,r5]
;;;259    	if( (reg_val&0x80000000) == 0)
00014a  0fd8              LSRS     r0,r3,#31
00014c  07c0              LSLS     r0,r0,#31
00014e  2800              CMP      r0,#0
000150  d100              BNE      |L1.340|
                  |L1.338|
;;;260    		return RESET;
;;;261    	else
;;;262    	{
;;;263    		*adc_data = (uint16_t)reg_val;
;;;264    		return SET;
;;;265    	}
;;;266    }
000152  bd30              POP      {r4,r5,pc}
                  |L1.340|
000154  800b              STRH     r3,[r1,#0]            ;263
000156  2001              MOVS     r0,#1                 ;264
000158  e7fb              B        |L1.338|
;;;267    
                          ENDP

                  ADC_GetHPConversionData PROC
;;;272     ************************************************************************************************************/
;;;273    FlagStatus ADC_GetHPConversionData(u8 ADC_HP_DATAx, u16 *adc_data)
00015a  b530              PUSH     {r4,r5,lr}
;;;274    {
00015c  4602              MOV      r2,r0
;;;275    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
00015e  4c4b              LDR      r4,|L1.652|
;;;276    	u32 reg_val;
;;;277    
;;;278    	reg_val = pAM_ADC->HDR[ADC_HP_DATAx];
000160  0095              LSLS     r5,r2,#2
000162  4620              MOV      r0,r4
000164  306c              ADDS     r0,r0,#0x6c
000166  5943              LDR      r3,[r0,r5]
;;;279    	if( (reg_val&0x80000000) == 0)
000168  0fd8              LSRS     r0,r3,#31
00016a  07c0              LSLS     r0,r0,#31
00016c  2800              CMP      r0,#0
00016e  d100              BNE      |L1.370|
                  |L1.368|
;;;280    		return RESET;
;;;281    	else
;;;282    	{
;;;283    		*adc_data = (uint16_t)reg_val;
;;;284    		return SET;	
;;;285    	}
;;;286    }
000170  bd30              POP      {r4,r5,pc}
                  |L1.370|
000172  800b              STRH     r3,[r1,#0]            ;283
000174  2001              MOVS     r0,#1                 ;284
000176  e7fb              B        |L1.368|
;;;287    
                          ENDP

                  ADC_IntConfig PROC
;;;305     ************************************************************************************************************/
;;;306    void ADC_IntConfig(u32 ADC_INT, ControlStatus NewState)
000178  b510              PUSH     {r4,lr}
;;;307    {
00017a  4602              MOV      r2,r0
;;;308    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
00017c  4843              LDR      r0,|L1.652|
;;;309    
;;;310      if(NewState != DISABLE)
00017e  2900              CMP      r1,#0
000180  d005              BEQ      |L1.398|
;;;311      {
;;;312        pAM_ADC->IER |= ADC_INT;
000182  2398              MOVS     r3,#0x98
000184  581b              LDR      r3,[r3,r0]
000186  4313              ORRS     r3,r3,r2
000188  2498              MOVS     r4,#0x98
00018a  5023              STR      r3,[r4,r0]
00018c  e004              B        |L1.408|
                  |L1.398|
;;;313      }
;;;314      else
;;;315      {
;;;316        pAM_ADC->IER &= ~ADC_INT;
00018e  2398              MOVS     r3,#0x98
000190  581b              LDR      r3,[r3,r0]
000192  4393              BICS     r3,r3,r2
000194  2498              MOVS     r4,#0x98
000196  5023              STR      r3,[r4,r0]
                  |L1.408|
;;;317      }
;;;318    }
000198  bd10              POP      {r4,pc}
;;;319    
                          ENDP

                  ADC_GetIntStatus PROC
;;;335     ************************************************************************************************************/
;;;336    FlagStatus ADC_GetIntStatus(u32 ADC_INT)
00019a  4601              MOV      r1,r0
;;;337    {
;;;338    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
00019c  4a3b              LDR      r2,|L1.652|
;;;339      FlagStatus Status;
;;;340    
;;;341      if((pAM_ADC->ISR & ADC_INT) != RESET)
00019e  23a0              MOVS     r3,#0xa0
0001a0  589b              LDR      r3,[r3,r2]
0001a2  400b              ANDS     r3,r3,r1
0001a4  2b00              CMP      r3,#0
0001a6  d001              BEQ      |L1.428|
;;;342      {
;;;343        Status = SET;
0001a8  2001              MOVS     r0,#1
0001aa  e000              B        |L1.430|
                  |L1.428|
;;;344      }
;;;345      else
;;;346      {
;;;347        Status = RESET;
0001ac  2000              MOVS     r0,#0
                  |L1.430|
;;;348      }
;;;349    
;;;350      return Status;
;;;351    }
0001ae  4770              BX       lr
;;;352    
                          ENDP

                  ADC_ClearIntPendingBit PROC
;;;368     ************************************************************************************************************/
;;;369    void ADC_ClearIntPendingBit(u32 ADC_INT)
0001b0  4936              LDR      r1,|L1.652|
;;;370    {
;;;371    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
;;;372    
;;;373      pAM_ADC->ICLR = ADC_INT;
0001b2  22a4              MOVS     r2,#0xa4
0001b4  5050              STR      r0,[r2,r1]
;;;374    }
0001b6  4770              BX       lr
;;;375    
                          ENDP

                  ADC_GetFlagStatus PROC
;;;391     ************************************************************************************************************/
;;;392    FlagStatus ADC_GetFlagStatus(u32 ADC_FLAG)
0001b8  4601              MOV      r1,r0
;;;393    {
;;;394    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
0001ba  4a34              LDR      r2,|L1.652|
;;;395      FlagStatus Status;
;;;396    
;;;397      if((pAM_ADC->IRAW & ADC_FLAG) != RESET)
0001bc  239c              MOVS     r3,#0x9c
0001be  589b              LDR      r3,[r3,r2]
0001c0  400b              ANDS     r3,r3,r1
0001c2  2b00              CMP      r3,#0
0001c4  d001              BEQ      |L1.458|
;;;398      {
;;;399        Status = SET;
0001c6  2001              MOVS     r0,#1
0001c8  e000              B        |L1.460|
                  |L1.458|
;;;400      }
;;;401      else
;;;402      {
;;;403        Status = RESET;
0001ca  2000              MOVS     r0,#0
                  |L1.460|
;;;404      }
;;;405    
;;;406      return Status;
;;;407    }
0001cc  4770              BX       lr
;;;408    
                          ENDP

                  ADC_AWDConfig PROC
;;;421     ************************************************************************************************************/
;;;422    void ADC_AWDConfig(u32 ADC_AWD)
0001ce  492f              LDR      r1,|L1.652|
;;;423    {
;;;424    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
;;;425    	
;;;426      pAM_ADC->WCR = (pAM_ADC->WCR & 0xFFFFFFF8) | ADC_AWD;
0001d0  228c              MOVS     r2,#0x8c
0001d2  5852              LDR      r2,[r2,r1]
0001d4  08d2              LSRS     r2,r2,#3
0001d6  00d2              LSLS     r2,r2,#3
0001d8  4302              ORRS     r2,r2,r0
0001da  238c              MOVS     r3,#0x8c
0001dc  505a              STR      r2,[r3,r1]
;;;427    }
0001de  4770              BX       lr
;;;428    
                          ENDP

                  ADC_AWDSingleChannelConfig PROC
;;;435     ************************************************************************************************************/
;;;436    void ADC_AWDSingleChannelConfig(u8 ADC_CH)
0001e0  492a              LDR      r1,|L1.652|
;;;437    {
;;;438    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
;;;439    	
;;;440      pAM_ADC->WCR = (pAM_ADC->WCR & 0xFFFFF0FF) | ((u32)ADC_CH << 8);
0001e2  228c              MOVS     r2,#0x8c
0001e4  5852              LDR      r2,[r2,r1]
0001e6  230f              MOVS     r3,#0xf
0001e8  021b              LSLS     r3,r3,#8
0001ea  439a              BICS     r2,r2,r3
0001ec  0203              LSLS     r3,r0,#8
0001ee  431a              ORRS     r2,r2,r3
0001f0  238c              MOVS     r3,#0x8c
0001f2  505a              STR      r2,[r3,r1]
;;;441    }
0001f4  4770              BX       lr
;;;442    
                          ENDP

                  ADC_AWDThresholdsConfig PROC
;;;448     ************************************************************************************************************/
;;;449    void ADC_AWDThresholdsConfig(u16 UPPER, u16 LOWER)
0001f6  4a25              LDR      r2,|L1.652|
;;;450    {
;;;451    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
;;;452    	
;;;453      pAM_ADC->LTR = LOWER;
0001f8  2390              MOVS     r3,#0x90
0001fa  5099              STR      r1,[r3,r2]
;;;454      pAM_ADC->UTR = UPPER;
0001fc  2394              MOVS     r3,#0x94
0001fe  5098              STR      r0,[r3,r2]
;;;455    }
000200  4770              BX       lr
;;;456    
                          ENDP

                  ADC_PDMAConfig PROC
;;;470     ************************************************************************************************************/
;;;471    void ADC_PDMAConfig(u32 ADC_PDMA, ControlStatus NewState)
000202  b510              PUSH     {r4,lr}
;;;472    {
000204  4602              MOV      r2,r0
;;;473    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
000206  4821              LDR      r0,|L1.652|
;;;474    	
;;;475      if(NewState != DISABLE)
000208  2900              CMP      r1,#0
00020a  d005              BEQ      |L1.536|
;;;476      {
;;;477        pAM_ADC->PDMAR |= ADC_PDMA;
00020c  23a8              MOVS     r3,#0xa8
00020e  581b              LDR      r3,[r3,r0]
000210  4313              ORRS     r3,r3,r2
000212  24a8              MOVS     r4,#0xa8
000214  5023              STR      r3,[r4,r0]
000216  e004              B        |L1.546|
                  |L1.536|
;;;478      }
;;;479      else
;;;480      {
;;;481        pAM_ADC->PDMAR &= ~ADC_PDMA;
000218  23a8              MOVS     r3,#0xa8
00021a  581b              LDR      r3,[r3,r0]
00021c  4393              BICS     r3,r3,r2
00021e  24a8              MOVS     r4,#0xa8
000220  5023              STR      r3,[r4,r0]
                  |L1.546|
;;;482      }
;;;483    }
000222  bd10              POP      {r4,pc}
;;;484    
                          ENDP

                  ADC_AlignConfig PROC
;;;489     ************************************************************************************************************/
;;;490    void ADC_AlignConfig(u8 Align)
000224  4919              LDR      r1,|L1.652|
;;;491    {
;;;492    	AM_ADC_TypeDef *pAM_ADC = AM_ADC;
;;;493    	
;;;494    	pAM_ADC->CTL = ((pAM_ADC->CTL)&(~(1<<1)))|(Align<<1); 
000226  680a              LDR      r2,[r1,#0]
000228  2302              MOVS     r3,#2
00022a  439a              BICS     r2,r2,r3
00022c  0043              LSLS     r3,r0,#1
00022e  431a              ORRS     r2,r2,r3
000230  600a              STR      r2,[r1,#0]
;;;495    }
000232  4770              BX       lr
;;;496    
                          ENDP

                  CS_Cmd PROC
;;;504     ************************************************************************************************************/
;;;505    void CS_Cmd(CSx Cs_x, ControlStatus NewState)
000234  b510              PUSH     {r4,lr}
;;;506    {
;;;507      if(NewState != DISABLE)
000236  2900              CMP      r1,#0
000238  d00a              BEQ      |L1.592|
;;;508      {
;;;509        AM_CS->CTL |= (1<<(0+Cs_x*8));
00023a  4a14              LDR      r2,|L1.652|
00023c  3280              ADDS     r2,r2,#0x80
00023e  6b52              LDR      r2,[r2,#0x34]
000240  00c3              LSLS     r3,r0,#3
000242  2401              MOVS     r4,#1
000244  409c              LSLS     r4,r4,r3
000246  4322              ORRS     r2,r2,r4
000248  4b10              LDR      r3,|L1.652|
00024a  3380              ADDS     r3,r3,#0x80
00024c  635a              STR      r2,[r3,#0x34]
00024e  e009              B        |L1.612|
                  |L1.592|
;;;510      }
;;;511      else
;;;512      {
;;;513        AM_CS->CTL &= (~(1<<(0+Cs_x*8)));
000250  4a0e              LDR      r2,|L1.652|
000252  3280              ADDS     r2,r2,#0x80
000254  6b52              LDR      r2,[r2,#0x34]
000256  00c3              LSLS     r3,r0,#3
000258  2401              MOVS     r4,#1
00025a  409c              LSLS     r4,r4,r3
00025c  43a2              BICS     r2,r2,r4
00025e  4b0b              LDR      r3,|L1.652|
000260  3380              ADDS     r3,r3,#0x80
000262  635a              STR      r2,[r3,#0x34]
                  |L1.612|
;;;514      }
;;;515    }
000264  bd10              POP      {r4,pc}
;;;516    
                          ENDP

                  CS_CurrentSel PROC
;;;523     ************************************************************************************************************/
;;;524    void CS_CurrentSel(CSx Cs_x, CS_CUR Cs_cur)
000266  b510              PUSH     {r4,lr}
;;;525    {
;;;526      AM_CS->CTL = (AM_CS->CTL & (~(3<<(1+Cs_x*8)))) | (Cs_cur<<(1+Cs_x*8));
000268  4a08              LDR      r2,|L1.652|
00026a  3280              ADDS     r2,r2,#0x80
00026c  6b52              LDR      r2,[r2,#0x34]
00026e  00c4              LSLS     r4,r0,#3
000270  1c64              ADDS     r4,r4,#1
000272  2303              MOVS     r3,#3
000274  40a3              LSLS     r3,r3,r4
000276  439a              BICS     r2,r2,r3
000278  00c3              LSLS     r3,r0,#3
00027a  1c5b              ADDS     r3,r3,#1
00027c  460c              MOV      r4,r1
00027e  409c              LSLS     r4,r4,r3
000280  4322              ORRS     r2,r2,r4
000282  4b02              LDR      r3,|L1.652|
000284  3380              ADDS     r3,r3,#0x80
000286  635a              STR      r2,[r3,#0x34]
;;;527    }
000288  bd10              POP      {r4,pc}
;;;528    /**
                          ENDP

00028a  0000              DCW      0x0000
                  |L1.652|
                          DCD      0x40010000

;*** Start embedded assembler ***

#line 1 "..\\driver\\src\\adc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_e11a2ea2____REV16|
#line 114 "..\\inc\\core_cmInstr.h"
|__asm___5_adc_c_e11a2ea2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_e11a2ea2____REVSH|
#line 128
|__asm___5_adc_c_e11a2ea2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
