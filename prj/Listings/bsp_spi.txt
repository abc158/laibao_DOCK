; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\bsp_spi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\bsp_spi.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\driver\inc -I.\src -I.\User -I.\User\led -I.\User\usart -I.\User\timer -I.\User\ir -I.\User\2.4G -I.\User\spi0 -IF:\1708\dock\prj\RTE -I"D:\Program Files (x86)\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM0\Include" -I"D:\Program Files (x86)\Keil_v5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DARMCM0 -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\bsp_spi.crf User\spi0\bsp_spi.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SPI0_Init PROC
;;;22     
;;;23     void SPI0_Init(void)
000000  b500              PUSH     {lr}
;;;24     {
000002  b08b              SUB      sp,sp,#0x2c
;;;25     SPI_InitTypeDef SPI_InitStructure;
;;;26     	
;;;27     	SPI_DeInit(FLASH_SPI);
000004  48fe              LDR      r0,|L1.1024|
000006  f7fffffe          BL       SPI_DeInit
;;;28     	
;;;29     	GPIO_PullResistorConfig(AM_GPIOD,AFIO_PIN_4,GPIO_PR_UP); //设置引脚为上拉模式
00000a  2200              MOVS     r2,#0
00000c  2110              MOVS     r1,#0x10
00000e  48fd              LDR      r0,|L1.1028|
000010  f7fffffe          BL       GPIO_PullResistorConfig
;;;30     	
;;;31     AFIO_GPDConfig(AFIO_PIN_6 ,AFIO_MODE_3);  //SPI0
000014  2103              MOVS     r1,#3
000016  2040              MOVS     r0,#0x40
000018  f7fffffe          BL       AFIO_GPDConfig
;;;32     AFIO_GPDConfig(AFIO_PIN_7 ,AFIO_MODE_3);  //PASS
00001c  2103              MOVS     r1,#3
00001e  2080              MOVS     r0,#0x80
000020  f7fffffe          BL       AFIO_GPDConfig
;;;33     //AFIO_GPDConfig(AFIO_PIN_4 ,AFIO_MODE_3);
;;;34     AFIO_GPDConfig(AFIO_PIN_5 ,AFIO_MODE_3);
000024  2103              MOVS     r1,#3
000026  2020              MOVS     r0,#0x20
000028  f7fffffe          BL       AFIO_GPDConfig
;;;35     	
;;;36     //AFIO_GPCConfig(AFIO_PIN_8 ,AFIO_MODE_3);  //SPI0
;;;37     //AFIO_GPCConfig(AFIO_PIN_9 ,AFIO_MODE_3);  //PASS
;;;38     //AFIO_GPCConfig(AFIO_PIN_10,AFIO_MODE_3);
;;;39     //AFIO_GPCConfig(AFIO_PIN_11,AFIO_MODE_3);
;;;40     	
;;;41     //AFIO_GPCConfig(AFIO_PIN_12,AFIO_MODE_3);  //SPI0
;;;42     //AFIO_GPCConfig(AFIO_PIN_13,AFIO_MODE_3);  //PASS
;;;43     //AFIO_GPDConfig(AFIO_PIN_2 ,AFIO_MODE_3);
;;;44     //AFIO_GPDConfig(AFIO_PIN_0 ,AFIO_MODE_3);
;;;45     	
;;;46     //AFIO_GPAConfig(AFIO_PIN_6 ,AFIO_MODE_3);  //SPI1
;;;47     //AFIO_GPAConfig(AFIO_PIN_7 ,AFIO_MODE_3);  //PASS
;;;48     //AFIO_GPAConfig(AFIO_PIN_8 ,AFIO_MODE_3);
;;;49     //AFIO_GPAConfig(AFIO_PIN_9 ,AFIO_MODE_3);
;;;50     	
;;;51     //	AFIO_GPCConfig(AFIO_PIN_4 ,AFIO_MODE_3);  //SPI1
;;;52     //	AFIO_GPCConfig(AFIO_PIN_5 ,AFIO_MODE_3);	//Failure
;;;53     //	AFIO_GPCConfig(AFIO_PIN_6 ,AFIO_MODE_3);
;;;54     //	AFIO_GPCConfig(AFIO_PIN_7 ,AFIO_MODE_3);
;;;55     	
;;;56     //AFIO_GPDConfig(AFIO_PIN_10,AFIO_MODE_3);  //SPI1
;;;57     //AFIO_GPDConfig(AFIO_PIN_11,AFIO_MODE_3);  //PASS
;;;58     //AFIO_GPDConfig(AFIO_PIN_12,AFIO_MODE_3);
;;;59     //AFIO_GPDConfig(AFIO_PIN_13,AFIO_MODE_3);
;;;60     	
;;;61     	SPI_StructInit(&SPI_InitStructure);
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       SPI_StructInit
;;;62     	SPI_InitStructure.SPI_ClockPrescaler = 2;
000032  2002              MOVS     r0,#2
000034  900a              STR      r0,[sp,#0x28]
;;;63     	SPI_InitStructure.SPI_DataLength = SPI_DATALENGTH_8;
000036  2008              MOVS     r0,#8
000038  9002              STR      r0,[sp,#8]
;;;64     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_FIRST;
00003a  2000              MOVS     r0,#0
00003c  9006              STR      r0,[sp,#0x18]
;;;65     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_LOW;              //空闲电平必须为低
00003e  9005              STR      r0,[sp,#0x14]
;;;66     	SPI_InitStructure.SPI_FIFO = SPI_FIFO_DISABLE;
000040  9001              STR      r0,[sp,#4]
;;;67     	SPI_InitStructure.SPI_FirstBit = SPI_FIRSTBIT_MSB;
000042  9007              STR      r0,[sp,#0x1c]
;;;68     	SPI_InitStructure.SPI_Mode = SPI_MASTER;
000044  2001              MOVS     r0,#1
000046  0380              LSLS     r0,r0,#14
000048  9000              STR      r0,[sp,#0]
;;;69     	SPI_InitStructure.SPI_SELMode = SPI_SEL_SOFTWARE;
00004a  2000              MOVS     r0,#0
00004c  9003              STR      r0,[sp,#0xc]
;;;70     	SPI_InitStructure.SPI_SELPolarity = SPI_SELPOLARITY_LOW;
00004e  9004              STR      r0,[sp,#0x10]
;;;71     //SPI_InitStructure.SPI_RxFIFOTriggerLevel = 8;
;;;72     //SPI_InitStructure.SPI_TxFIFOTriggerLevel = 7;
;;;73     	SPI_Init(FLASH_SPI,&SPI_InitStructure);
000050  4669              MOV      r1,sp
000052  48eb              LDR      r0,|L1.1024|
000054  f7fffffe          BL       SPI_Init
;;;74     //	
;;;75     	SPI_SELOutputCmd(FLASH_SPI,ENABLE);
000058  2101              MOVS     r1,#1
00005a  48e9              LDR      r0,|L1.1024|
00005c  f7fffffe          BL       SPI_SELOutputCmd
;;;76     	SPI_SoftwareSELCmd(FLASH_SPI,SPI_SEL_INACTIVE);
000060  2110              MOVS     r1,#0x10
000062  43c9              MVNS     r1,r1
000064  48e6              LDR      r0,|L1.1024|
000066  f7fffffe          BL       SPI_SoftwareSELCmd
;;;77     	SPI_Cmd(FLASH_SPI,ENABLE);
00006a  2101              MOVS     r1,#1
00006c  48e4              LDR      r0,|L1.1024|
00006e  f7fffffe          BL       SPI_Cmd
;;;78     	SPI_IntConfig(FLASH_SPI,SPI_INT_TXE,ENABLE);
000072  2201              MOVS     r2,#1
000074  2102              MOVS     r1,#2
000076  48e2              LDR      r0,|L1.1024|
000078  f7fffffe          BL       SPI_IntConfig
;;;79     	SPI_IntConfig(FLASH_SPI,SPI_INT_RXBNE,ENABLE);
00007c  2201              MOVS     r2,#1
00007e  2104              MOVS     r1,#4
000080  48df              LDR      r0,|L1.1024|
000082  f7fffffe          BL       SPI_IntConfig
;;;80     	SPI_FLASH_CS_HIGH();
000086  20ff              MOVS     r0,#0xff
000088  3001              ADDS     r0,#1
00008a  49de              LDR      r1,|L1.1028|
00008c  6248              STR      r0,[r1,#0x24]
;;;81     }
00008e  b00b              ADD      sp,sp,#0x2c
000090  bd00              POP      {pc}
;;;82     
                          ENDP

                  SPI_RW_Byte PROC
;;;83     uint8_t SPI_RW_Byte(uint8_t byte)
000092  b510              PUSH     {r4,lr}
;;;84     {
000094  4604              MOV      r4,r0
;;;85     	/* 等待发送缓冲区为空，TXE事件 */
;;;86       while (SPI_GetFlagStatus(FLASH_SPI, SPI_INT_TXE) == RESET){}
000096  bf00              NOP      
                  |L1.152|
000098  2102              MOVS     r1,#2
00009a  48d9              LDR      r0,|L1.1024|
00009c  f7fffffe          BL       SPI_GetFlagStatus
0000a0  2800              CMP      r0,#0
0000a2  d0f9              BEQ      |L1.152|
;;;87     
;;;88       /* 写入数据寄存器，把要写入的数据写入发送缓冲区 */
;;;89       SPI_SendData(FLASH_SPI, byte);
0000a4  4621              MOV      r1,r4
0000a6  48d6              LDR      r0,|L1.1024|
0000a8  f7fffffe          BL       SPI_SendData
;;;90     
;;;91       /* 等待接收缓冲区非空，RXNE事件 */
;;;92       while (SPI_GetFlagStatus(FLASH_SPI, SPI_INT_RXBNE) == RESET){}
0000ac  bf00              NOP      
                  |L1.174|
0000ae  2104              MOVS     r1,#4
0000b0  48d3              LDR      r0,|L1.1024|
0000b2  f7fffffe          BL       SPI_GetFlagStatus
0000b6  2800              CMP      r0,#0
0000b8  d0f9              BEQ      |L1.174|
;;;93     
;;;94       /* 读取数据寄存器，获取接收缓冲区数据 */
;;;95       return SPI_ReceiveData(FLASH_SPI);
0000ba  48d1              LDR      r0,|L1.1024|
0000bc  f7fffffe          BL       SPI_ReceiveData
0000c0  b2c0              UXTB     r0,r0
;;;96     }
0000c2  bd10              POP      {r4,pc}
;;;97     
                          ENDP

                  SPI_FLASH_ReadByte PROC
;;;98     uint8_t SPI_FLASH_ReadByte(void)
0000c4  b510              PUSH     {r4,lr}
;;;99     {
;;;100    	return (SPI_RW_Byte(Dummy_Byte));
0000c6  20ff              MOVS     r0,#0xff
0000c8  f7fffffe          BL       SPI_RW_Byte
;;;101    }
0000cc  bd10              POP      {r4,pc}
;;;102    
                          ENDP

                  SPI_FLASH_WriteEnable PROC
;;;107      */
;;;108    void SPI_FLASH_WriteEnable(void)
0000ce  b510              PUSH     {r4,lr}
;;;109    {
;;;110      /* 通讯开始：CS低 */
;;;111      SPI_FLASH_CS_LOW();
0000d0  20ff              MOVS     r0,#0xff
0000d2  3001              ADDS     r0,#1
0000d4  49cb              LDR      r1,|L1.1028|
0000d6  6288              STR      r0,[r1,#0x28]
;;;112    
;;;113      /* 发送写使能命令*/
;;;114      SPI_RW_Byte(W25X_WriteEnable);
0000d8  2006              MOVS     r0,#6
0000da  f7fffffe          BL       SPI_RW_Byte
;;;115    
;;;116      /*通讯结束：CS高 */
;;;117      SPI_FLASH_CS_HIGH();
0000de  20ff              MOVS     r0,#0xff
0000e0  3001              ADDS     r0,#1
0000e2  49c8              LDR      r1,|L1.1028|
0000e4  6248              STR      r0,[r1,#0x24]
;;;118    }
0000e6  bd10              POP      {r4,pc}
;;;119    
                          ENDP

                  SPI_FLASH_WaitForWriteEnd PROC
;;;124      */
;;;125    void SPI_FLASH_WaitForWriteEnd(void)
0000e8  b510              PUSH     {r4,lr}
;;;126    {
;;;127      u8 FLASH_Status = 0;
0000ea  2400              MOVS     r4,#0
;;;128    
;;;129      /* 选择 FLASH: CS 低 */
;;;130      SPI_FLASH_CS_LOW();
0000ec  20ff              MOVS     r0,#0xff
0000ee  3001              ADDS     r0,#1
0000f0  49c4              LDR      r1,|L1.1028|
0000f2  6288              STR      r0,[r1,#0x28]
;;;131    
;;;132      /* 发送 读状态寄存器 命令 */
;;;133      SPI_RW_Byte(W25X_ReadStatusReg);
0000f4  2005              MOVS     r0,#5
0000f6  f7fffffe          BL       SPI_RW_Byte
;;;134    	
;;;135      /* 若FLASH忙碌，则等待 */
;;;136      do
0000fa  bf00              NOP      
                  |L1.252|
;;;137      {
;;;138        /* 读取FLASH芯片的状态寄存器 */
;;;139        FLASH_Status = SPI_RW_Byte(Dummy_Byte);
0000fc  20ff              MOVS     r0,#0xff
0000fe  f7fffffe          BL       SPI_RW_Byte
000102  4604              MOV      r4,r0
;;;140      }
;;;141      while ((FLASH_Status & WIP_Flag) == SET); /* 正在写入标志 */
000104  07e0              LSLS     r0,r4,#31
000106  0fc0              LSRS     r0,r0,#31
000108  2800              CMP      r0,#0
00010a  d1f7              BNE      |L1.252|
;;;142    
;;;143      /* 停止信号  FLASH: CS 高 */
;;;144      SPI_FLASH_CS_HIGH();
00010c  20ff              MOVS     r0,#0xff
00010e  3001              ADDS     r0,#1
000110  49bc              LDR      r1,|L1.1028|
000112  6248              STR      r0,[r1,#0x24]
;;;145    }
000114  bd10              POP      {r4,pc}
;;;146    
                          ENDP

                  SPI_Flash_PowerDown PROC
;;;148    //进入掉电模式
;;;149    void SPI_Flash_PowerDown(void)   
000116  b510              PUSH     {r4,lr}
;;;150    { 
;;;151      /* 选择 FLASH: CS 低 */
;;;152      SPI_FLASH_CS_LOW();
000118  20ff              MOVS     r0,#0xff
00011a  3001              ADDS     r0,#1
00011c  49b9              LDR      r1,|L1.1028|
00011e  6288              STR      r0,[r1,#0x28]
;;;153    
;;;154      /* 发送 掉电 命令 */
;;;155      SPI_RW_Byte(W25X_PowerDown);
000120  20b9              MOVS     r0,#0xb9
000122  f7fffffe          BL       SPI_RW_Byte
;;;156    
;;;157      /* 停止信号  FLASH: CS 高 */
;;;158      SPI_FLASH_CS_HIGH();
000126  20ff              MOVS     r0,#0xff
000128  3001              ADDS     r0,#1
00012a  49b6              LDR      r1,|L1.1028|
00012c  6248              STR      r0,[r1,#0x24]
;;;159    }   
00012e  bd10              POP      {r4,pc}
;;;160    
                          ENDP

                  SPI_Flash_WAKEUP PROC
;;;161    //唤醒
;;;162    void SPI_Flash_WAKEUP(void)   
000130  b510              PUSH     {r4,lr}
;;;163    {
;;;164      /*选择 FLASH: CS 低 */
;;;165      SPI_FLASH_CS_LOW();
000132  20ff              MOVS     r0,#0xff
000134  3001              ADDS     r0,#1
000136  49b3              LDR      r1,|L1.1028|
000138  6288              STR      r0,[r1,#0x28]
;;;166    
;;;167      /* 发上 上电 命令 */
;;;168      SPI_RW_Byte(W25X_ReleasePowerDown);
00013a  20ab              MOVS     r0,#0xab
00013c  f7fffffe          BL       SPI_RW_Byte
;;;169    
;;;170      /* 停止信号 FLASH: CS 高 */
;;;171      SPI_FLASH_CS_HIGH();                   //等待TRES1
000140  20ff              MOVS     r0,#0xff
000142  3001              ADDS     r0,#1
000144  49af              LDR      r1,|L1.1028|
000146  6248              STR      r0,[r1,#0x24]
;;;172    }
000148  bd10              POP      {r4,pc}
;;;173    
                          ENDP

                  SPI_FLASH_SectorErase PROC
;;;178      */
;;;179    void SPI_FLASH_SectorErase(uint32_t SectorAddr)
00014a  b510              PUSH     {r4,lr}
;;;180    {
00014c  4604              MOV      r4,r0
;;;181      /* 发送FLASH写使能命令 */
;;;182      SPI_FLASH_WriteEnable();
00014e  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;183      SPI_FLASH_WaitForWriteEnd();
000152  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;184      /* 擦除扇区 */
;;;185      /* 选择FLASH: CS低电平 */
;;;186      SPI_FLASH_CS_LOW();
000156  20ff              MOVS     r0,#0xff
000158  3001              ADDS     r0,#1
00015a  49aa              LDR      r1,|L1.1028|
00015c  6288              STR      r0,[r1,#0x28]
;;;187      /* 发送扇区擦除指令*/
;;;188      SPI_RW_Byte(W25X_SectorErase);
00015e  2020              MOVS     r0,#0x20
000160  f7fffffe          BL       SPI_RW_Byte
;;;189      /*发送擦除扇区地址的高位*/
;;;190      SPI_RW_Byte((SectorAddr & 0xFF0000) >> 16);
000164  21ff              MOVS     r1,#0xff
000166  0409              LSLS     r1,r1,#16
000168  4021              ANDS     r1,r1,r4
00016a  0c08              LSRS     r0,r1,#16
00016c  f7fffffe          BL       SPI_RW_Byte
;;;191      /* 发送擦除扇区地址的中位 */
;;;192      SPI_RW_Byte((SectorAddr & 0xFF00) >> 8);
000170  21ff              MOVS     r1,#0xff
000172  0209              LSLS     r1,r1,#8
000174  4021              ANDS     r1,r1,r4
000176  0a08              LSRS     r0,r1,#8
000178  f7fffffe          BL       SPI_RW_Byte
;;;193      /* 发送擦除扇区地址的低位 */
;;;194      SPI_RW_Byte(SectorAddr & 0xFF);
00017c  b2e0              UXTB     r0,r4
00017e  f7fffffe          BL       SPI_RW_Byte
;;;195      /* 停止信号 FLASH: CS 高电平 */
;;;196      SPI_FLASH_CS_HIGH();
000182  20ff              MOVS     r0,#0xff
000184  3001              ADDS     r0,#1
000186  499f              LDR      r1,|L1.1028|
000188  6248              STR      r0,[r1,#0x24]
;;;197      /* 等待擦除完毕*/
;;;198      SPI_FLASH_WaitForWriteEnd();
00018a  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;199    }
00018e  bd10              POP      {r4,pc}
;;;200    
                          ENDP

                  SPI_FLASH_BulkErase PROC
;;;206      */
;;;207    void SPI_FLASH_BulkErase(void)
000190  b510              PUSH     {r4,lr}
;;;208    {
;;;209      /* 发送FLASH写使能命令 */
;;;210      SPI_FLASH_WriteEnable();
000192  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;211    
;;;212      /* 整块 Erase */
;;;213      /* 选择FLASH: CS低电平 */
;;;214      SPI_FLASH_CS_LOW();
000196  20ff              MOVS     r0,#0xff
000198  3001              ADDS     r0,#1
00019a  499a              LDR      r1,|L1.1028|
00019c  6288              STR      r0,[r1,#0x28]
;;;215      /* 发送整块擦除指令*/
;;;216      SPI_RW_Byte(W25X_ChipErase);
00019e  20c7              MOVS     r0,#0xc7
0001a0  f7fffffe          BL       SPI_RW_Byte
;;;217      /* 停止信号 FLASH: CS 高电平 */
;;;218      SPI_FLASH_CS_HIGH();
0001a4  20ff              MOVS     r0,#0xff
0001a6  3001              ADDS     r0,#1
0001a8  4996              LDR      r1,|L1.1028|
0001aa  6248              STR      r0,[r1,#0x24]
;;;219    
;;;220      /* 等待擦除完毕*/
;;;221      SPI_FLASH_WaitForWriteEnd();
0001ac  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;222    }
0001b0  bd10              POP      {r4,pc}
;;;223    
                          ENDP

                  SPI_FLASH_PageWrite PROC
;;;232      */
;;;233    void SPI_FLASH_PageWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite)
0001b2  b570              PUSH     {r4-r6,lr}
;;;234    {
0001b4  4605              MOV      r5,r0
0001b6  460c              MOV      r4,r1
0001b8  4616              MOV      r6,r2
;;;235      /* 发送FLASH写使能命令 */
;;;236      SPI_FLASH_WriteEnable();
0001ba  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;237    
;;;238      /* 选择FLASH: CS低电平 */
;;;239      SPI_FLASH_CS_LOW();
0001be  20ff              MOVS     r0,#0xff
0001c0  3001              ADDS     r0,#1
0001c2  4990              LDR      r1,|L1.1028|
0001c4  6288              STR      r0,[r1,#0x28]
;;;240      /* 写页写指令*/
;;;241      SPI_RW_Byte(W25X_PageProgram);
0001c6  2002              MOVS     r0,#2
0001c8  f7fffffe          BL       SPI_RW_Byte
;;;242      /*发送写地址的高位*/
;;;243      SPI_RW_Byte((WriteAddr & 0xFF0000) >> 16);
0001cc  21ff              MOVS     r1,#0xff
0001ce  0409              LSLS     r1,r1,#16
0001d0  4021              ANDS     r1,r1,r4
0001d2  0c08              LSRS     r0,r1,#16
0001d4  f7fffffe          BL       SPI_RW_Byte
;;;244      /*发送写地址的中位*/
;;;245      SPI_RW_Byte((WriteAddr & 0xFF00) >> 8);
0001d8  21ff              MOVS     r1,#0xff
0001da  0209              LSLS     r1,r1,#8
0001dc  4021              ANDS     r1,r1,r4
0001de  0a08              LSRS     r0,r1,#8
0001e0  f7fffffe          BL       SPI_RW_Byte
;;;246      /*发送写地址的低位*/
;;;247      SPI_RW_Byte(WriteAddr & 0xFF);
0001e4  b2e0              UXTB     r0,r4
0001e6  f7fffffe          BL       SPI_RW_Byte
;;;248    
;;;249      if(NumByteToWrite > SPI_FLASH_PerWritePageSize)
0001ea  20ff              MOVS     r0,#0xff
0001ec  3001              ADDS     r0,#1
0001ee  4286              CMP      r6,r0
0001f0  dd03              BLE      |L1.506|
;;;250      {
;;;251         NumByteToWrite = SPI_FLASH_PerWritePageSize;
0001f2  4606              MOV      r6,r0
;;;252    		 #if defined (FLASH_DEBUG)
;;;253         printf("SPI_FLASH_PageWrite too large!");
0001f4  a084              ADR      r0,|L1.1032|
0001f6  f7fffffe          BL       __2printf
                  |L1.506|
;;;254    		#endif
;;;255      }
;;;256    
;;;257      /* 写入数据*/
;;;258      while (NumByteToWrite--)
0001fa  e003              B        |L1.516|
                  |L1.508|
;;;259      {
;;;260        /* 发送当前要写入的字节数据 */
;;;261        SPI_RW_Byte(*pBuffer);
0001fc  7828              LDRB     r0,[r5,#0]
0001fe  f7fffffe          BL       SPI_RW_Byte
;;;262        /* 指向下一字节数据 */
;;;263        pBuffer++;
000202  1c6d              ADDS     r5,r5,#1
                  |L1.516|
000204  4630              MOV      r0,r6                 ;258
000206  1e71              SUBS     r1,r6,#1              ;258
000208  b28e              UXTH     r6,r1                 ;258
00020a  2800              CMP      r0,#0                 ;258
00020c  d1f6              BNE      |L1.508|
;;;264      }
;;;265    
;;;266      /* 停止信号 FLASH: CS 高电平 */
;;;267      SPI_FLASH_CS_HIGH();
00020e  20ff              MOVS     r0,#0xff
000210  3001              ADDS     r0,#1
000212  497c              LDR      r1,|L1.1028|
000214  6248              STR      r0,[r1,#0x24]
;;;268    
;;;269      /* 等待写入完毕*/
;;;270      SPI_FLASH_WaitForWriteEnd();
000216  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;271    }
00021a  bd70              POP      {r4-r6,pc}
;;;272    
                          ENDP

                  SPI_FLASH_BufferWrite PROC
;;;280      */
;;;281    void SPI_FLASH_BufferWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite)
00021c  b5f0              PUSH     {r4-r7,lr}
;;;282    {
00021e  b085              SUB      sp,sp,#0x14
000220  4607              MOV      r7,r0
000222  460e              MOV      r6,r1
000224  4614              MOV      r4,r2
;;;283      uint8_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
000226  2000              MOVS     r0,#0
000228  9003              STR      r0,[sp,#0xc]
00022a  9002              STR      r0,[sp,#8]
00022c  9001              STR      r0,[sp,#4]
00022e  2500              MOVS     r5,#0
000230  9000              STR      r0,[sp,#0]
;;;284    	
;;;285    	/*mod运算求余，若writeAddr是SPI_FLASH_PageSize整数倍，运算结果Addr值为0*/
;;;286      Addr = WriteAddr % SPI_FLASH_PageSize;
000232  b2f0              UXTB     r0,r6
000234  9001              STR      r0,[sp,#4]
;;;287    	
;;;288    	/*差count个数据值，刚好可以对齐到页地址*/
;;;289      count = SPI_FLASH_PageSize - Addr;	
000236  21ff              MOVS     r1,#0xff
000238  3101              ADDS     r1,#1
00023a  9801              LDR      r0,[sp,#4]
00023c  1a08              SUBS     r0,r1,r0
00023e  b2c5              UXTB     r5,r0
;;;290    	/*计算出要写多少整数页*/
;;;291      NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
000240  4620              MOV      r0,r4
000242  17e1              ASRS     r1,r4,#31
000244  0e09              LSRS     r1,r1,#24
000246  1809              ADDS     r1,r1,r0
000248  0409              LSLS     r1,r1,#16
00024a  0e09              LSRS     r1,r1,#24
00024c  9103              STR      r1,[sp,#0xc]
;;;292    	/*mod运算求余，计算出剩余不满一页的字节数*/
;;;293      NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
00024e  17e1              ASRS     r1,r4,#31
000250  0e09              LSRS     r1,r1,#24
000252  1809              ADDS     r1,r1,r0
000254  1209              ASRS     r1,r1,#8
000256  0209              LSLS     r1,r1,#8
000258  1a61              SUBS     r1,r4,r1
00025a  b2c9              UXTB     r1,r1
00025c  9102              STR      r1,[sp,#8]
;;;294    
;;;295    	 /* Addr=0,则WriteAddr 刚好按页对齐 aligned  */
;;;296      if (Addr == 0) 
00025e  9801              LDR      r0,[sp,#4]
000260  2800              CMP      r0,#0
000262  d11f              BNE      |L1.676|
;;;297      {
;;;298    		/* NumByteToWrite < SPI_FLASH_PageSize */
;;;299        if (NumOfPage == 0) 
000264  9803              LDR      r0,[sp,#0xc]
000266  2800              CMP      r0,#0
000268  d105              BNE      |L1.630|
;;;300        {
;;;301          SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
00026a  4622              MOV      r2,r4
00026c  4631              MOV      r1,r6
00026e  4638              MOV      r0,r7
000270  f7fffffe          BL       SPI_FLASH_PageWrite
000274  e064              B        |L1.832|
                  |L1.630|
;;;302        }
;;;303        else /* NumByteToWrite > SPI_FLASH_PageSize */
;;;304        {
;;;305    			/*先把整数页都写了*/
;;;306          while (NumOfPage--)
000276  e009              B        |L1.652|
                  |L1.632|
;;;307          {
;;;308            SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
000278  22ff              MOVS     r2,#0xff
00027a  3201              ADDS     r2,#1
00027c  4631              MOV      r1,r6
00027e  4638              MOV      r0,r7
000280  f7fffffe          BL       SPI_FLASH_PageWrite
;;;309            WriteAddr +=  SPI_FLASH_PageSize;
000284  36ff              ADDS     r6,r6,#0xff
000286  3601              ADDS     r6,#1
;;;310            pBuffer += SPI_FLASH_PageSize;
000288  37ff              ADDS     r7,r7,#0xff
00028a  3701              ADDS     r7,#1
                  |L1.652|
00028c  9803              LDR      r0,[sp,#0xc]          ;306
00028e  1e41              SUBS     r1,r0,#1              ;306
000290  b2c9              UXTB     r1,r1                 ;306
000292  9103              STR      r1,[sp,#0xc]          ;306
000294  2800              CMP      r0,#0                 ;306
000296  d1ef              BNE      |L1.632|
;;;311          }
;;;312    			
;;;313    			/*若有多余的不满一页的数据，把它写完*/
;;;314          SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
000298  4631              MOV      r1,r6
00029a  4638              MOV      r0,r7
00029c  9a02              LDR      r2,[sp,#8]
00029e  f7fffffe          BL       SPI_FLASH_PageWrite
0002a2  e04d              B        |L1.832|
                  |L1.676|
;;;315        }
;;;316      }
;;;317    	/* 若地址与 SPI_FLASH_PageSize 不对齐  */
;;;318      else 
;;;319      {
;;;320    		/* NumByteToWrite < SPI_FLASH_PageSize */
;;;321        if (NumOfPage == 0) 
0002a4  9803              LDR      r0,[sp,#0xc]
0002a6  2800              CMP      r0,#0
0002a8  d119              BNE      |L1.734|
;;;322        {
;;;323    			/*当前页剩余的count个位置比NumOfSingle小，写不完*/
;;;324          if (NumOfSingle > count) 
0002aa  9802              LDR      r0,[sp,#8]
0002ac  42a8              CMP      r0,r5
0002ae  dd10              BLE      |L1.722|
;;;325          {
;;;326            temp = NumOfSingle - count;
0002b0  9802              LDR      r0,[sp,#8]
0002b2  1b40              SUBS     r0,r0,r5
0002b4  b2c0              UXTB     r0,r0
0002b6  9000              STR      r0,[sp,#0]
;;;327    				
;;;328    				/*先写满当前页*/
;;;329            SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
0002b8  462a              MOV      r2,r5
0002ba  4631              MOV      r1,r6
0002bc  4638              MOV      r0,r7
0002be  f7fffffe          BL       SPI_FLASH_PageWrite
;;;330            WriteAddr +=  count;
0002c2  1976              ADDS     r6,r6,r5
;;;331            pBuffer += count;
0002c4  197f              ADDS     r7,r7,r5
;;;332    				
;;;333    				/*再写剩余的数据*/
;;;334            SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
0002c6  4631              MOV      r1,r6
0002c8  4638              MOV      r0,r7
0002ca  9a00              LDR      r2,[sp,#0]
0002cc  f7fffffe          BL       SPI_FLASH_PageWrite
0002d0  e036              B        |L1.832|
                  |L1.722|
;;;335          }
;;;336          else /*当前页剩余的count个位置能写完NumOfSingle个数据*/
;;;337          {				
;;;338            SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
0002d2  4622              MOV      r2,r4
0002d4  4631              MOV      r1,r6
0002d6  4638              MOV      r0,r7
0002d8  f7fffffe          BL       SPI_FLASH_PageWrite
0002dc  e030              B        |L1.832|
                  |L1.734|
;;;339          }
;;;340        }
;;;341        else /* NumByteToWrite > SPI_FLASH_PageSize */
;;;342        {
;;;343    			/*地址不对齐多出的count分开处理，不加入这个运算*/
;;;344          NumByteToWrite -= count;
0002de  1b60              SUBS     r0,r4,r5
0002e0  b284              UXTH     r4,r0
;;;345          NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
0002e2  4620              MOV      r0,r4
0002e4  17e1              ASRS     r1,r4,#31
0002e6  0e09              LSRS     r1,r1,#24
0002e8  1809              ADDS     r1,r1,r0
0002ea  0409              LSLS     r1,r1,#16
0002ec  0e09              LSRS     r1,r1,#24
0002ee  9103              STR      r1,[sp,#0xc]
;;;346          NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
0002f0  17e1              ASRS     r1,r4,#31
0002f2  0e09              LSRS     r1,r1,#24
0002f4  1809              ADDS     r1,r1,r0
0002f6  1209              ASRS     r1,r1,#8
0002f8  0209              LSLS     r1,r1,#8
0002fa  1a61              SUBS     r1,r4,r1
0002fc  b2c9              UXTB     r1,r1
0002fe  9102              STR      r1,[sp,#8]
;;;347    
;;;348          SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
000300  462a              MOV      r2,r5
000302  4631              MOV      r1,r6
000304  4638              MOV      r0,r7
000306  f7fffffe          BL       SPI_FLASH_PageWrite
;;;349          WriteAddr +=  count;
00030a  1976              ADDS     r6,r6,r5
;;;350          pBuffer += count;
00030c  197f              ADDS     r7,r7,r5
;;;351    			
;;;352    			/*把整数页都写了*/
;;;353          while (NumOfPage--)
00030e  e009              B        |L1.804|
                  |L1.784|
;;;354          {
;;;355            SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
000310  22ff              MOVS     r2,#0xff
000312  3201              ADDS     r2,#1
000314  4631              MOV      r1,r6
000316  4638              MOV      r0,r7
000318  f7fffffe          BL       SPI_FLASH_PageWrite
;;;356            WriteAddr +=  SPI_FLASH_PageSize;
00031c  36ff              ADDS     r6,r6,#0xff
00031e  3601              ADDS     r6,#1
;;;357            pBuffer += SPI_FLASH_PageSize;
000320  37ff              ADDS     r7,r7,#0xff
000322  3701              ADDS     r7,#1
                  |L1.804|
000324  9803              LDR      r0,[sp,#0xc]          ;353
000326  1e41              SUBS     r1,r0,#1              ;353
000328  b2c9              UXTB     r1,r1                 ;353
00032a  9103              STR      r1,[sp,#0xc]          ;353
00032c  2800              CMP      r0,#0                 ;353
00032e  d1ef              BNE      |L1.784|
;;;358          }
;;;359    			/*若有多余的不满一页的数据，把它写完*/
;;;360          if (NumOfSingle != 0)
000330  9802              LDR      r0,[sp,#8]
000332  2800              CMP      r0,#0
000334  d004              BEQ      |L1.832|
;;;361          {
;;;362            SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
000336  4631              MOV      r1,r6
000338  4638              MOV      r0,r7
00033a  9a02              LDR      r2,[sp,#8]
00033c  f7fffffe          BL       SPI_FLASH_PageWrite
                  |L1.832|
;;;363          }
;;;364        }
;;;365      }
;;;366    }
000340  b005              ADD      sp,sp,#0x14
000342  bdf0              POP      {r4-r7,pc}
;;;367    
                          ENDP

                  SPI_FLASH_BufferRead PROC
;;;374      */
;;;375    void SPI_FLASH_BufferRead(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead)
000344  b570              PUSH     {r4-r6,lr}
;;;376    {
000346  4605              MOV      r5,r0
000348  460c              MOV      r4,r1
00034a  4616              MOV      r6,r2
;;;377      /* 选择FLASH: CS低电平 */
;;;378      SPI_FLASH_CS_LOW();
00034c  20ff              MOVS     r0,#0xff
00034e  3001              ADDS     r0,#1
000350  492c              LDR      r1,|L1.1028|
000352  6288              STR      r0,[r1,#0x28]
;;;379    
;;;380      /* 发送 读 指令 */
;;;381      SPI_RW_Byte(W25X_ReadData);
000354  2003              MOVS     r0,#3
000356  f7fffffe          BL       SPI_RW_Byte
;;;382    
;;;383      /* 发送 读 地址高位 */
;;;384      SPI_RW_Byte((ReadAddr & 0xFF0000) >> 16);
00035a  21ff              MOVS     r1,#0xff
00035c  0409              LSLS     r1,r1,#16
00035e  4021              ANDS     r1,r1,r4
000360  0c08              LSRS     r0,r1,#16
000362  f7fffffe          BL       SPI_RW_Byte
;;;385      /* 发送 读 地址中位 */
;;;386      SPI_RW_Byte((ReadAddr& 0xFF00) >> 8);
000366  21ff              MOVS     r1,#0xff
000368  0209              LSLS     r1,r1,#8
00036a  4021              ANDS     r1,r1,r4
00036c  0a08              LSRS     r0,r1,#8
00036e  f7fffffe          BL       SPI_RW_Byte
;;;387      /* 发送 读 地址低位 */
;;;388      SPI_RW_Byte(ReadAddr & 0xFF);
000372  b2e0              UXTB     r0,r4
000374  f7fffffe          BL       SPI_RW_Byte
;;;389      
;;;390    	/* 读取数据 */
;;;391      while (NumByteToRead--)
000378  e004              B        |L1.900|
                  |L1.890|
;;;392      {
;;;393        /* 读取一个字节*/
;;;394        *pBuffer = SPI_RW_Byte(Dummy_Byte);
00037a  20ff              MOVS     r0,#0xff
00037c  f7fffffe          BL       SPI_RW_Byte
000380  7028              STRB     r0,[r5,#0]
;;;395        /* 指向下一个字节缓冲区 */
;;;396        pBuffer++;
000382  1c6d              ADDS     r5,r5,#1
                  |L1.900|
000384  4630              MOV      r0,r6                 ;391
000386  1e71              SUBS     r1,r6,#1              ;391
000388  b28e              UXTH     r6,r1                 ;391
00038a  2800              CMP      r0,#0                 ;391
00038c  d1f5              BNE      |L1.890|
;;;397      }
;;;398    
;;;399      /* 停止信号 FLASH: CS 高电平 */
;;;400      SPI_FLASH_CS_HIGH();
00038e  20ff              MOVS     r0,#0xff
000390  3001              ADDS     r0,#1
000392  491c              LDR      r1,|L1.1028|
000394  6248              STR      r0,[r1,#0x24]
;;;401    }
000396  bd70              POP      {r4-r6,pc}
;;;402    
                          ENDP

                  SPI_FLASH_ReadID PROC
;;;408      */
;;;409    uint32_t SPI_FLASH_ReadID(void)
000398  b5f8              PUSH     {r3-r7,lr}
;;;410    {
;;;411      uint32_t Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;
00039a  2400              MOVS     r4,#0
00039c  2500              MOVS     r5,#0
00039e  2600              MOVS     r6,#0
0003a0  2700              MOVS     r7,#0
;;;412    
;;;413      /* 开始通讯：CS低电平 */
;;;414      SPI_FLASH_CS_LOW();
0003a2  20ff              MOVS     r0,#0xff
0003a4  3001              ADDS     r0,#1
0003a6  4917              LDR      r1,|L1.1028|
0003a8  6288              STR      r0,[r1,#0x28]
;;;415    
;;;416      /* 发送JEDEC指令，读取ID */
;;;417      SPI_RW_Byte(W25X_JedecDeviceID);
0003aa  209f              MOVS     r0,#0x9f
0003ac  f7fffffe          BL       SPI_RW_Byte
;;;418    
;;;419      /* 读取一个字节数据 */
;;;420      Temp0 = SPI_RW_Byte(Dummy_Byte);
0003b0  20ff              MOVS     r0,#0xff
0003b2  f7fffffe          BL       SPI_RW_Byte
0003b6  4605              MOV      r5,r0
;;;421    
;;;422      /* 读取一个字节数据 */
;;;423      Temp1 = SPI_RW_Byte(Dummy_Byte);
0003b8  20ff              MOVS     r0,#0xff
0003ba  f7fffffe          BL       SPI_RW_Byte
0003be  4606              MOV      r6,r0
;;;424    
;;;425      /* 读取一个字节数据 */
;;;426      Temp2 = SPI_RW_Byte(Dummy_Byte);
0003c0  20ff              MOVS     r0,#0xff
0003c2  f7fffffe          BL       SPI_RW_Byte
0003c6  4607              MOV      r7,r0
;;;427    
;;;428      /* 停止通讯：CS高电平 */
;;;429      SPI_FLASH_CS_HIGH();
0003c8  20ff              MOVS     r0,#0xff
0003ca  3001              ADDS     r0,#1
0003cc  490d              LDR      r1,|L1.1028|
0003ce  6248              STR      r0,[r1,#0x24]
;;;430    
;;;431    	/*把数据组合起来，作为函数的返回值*/
;;;432      Temp = (Temp0 << 16) | (Temp1 << 8) | Temp2;
0003d0  0428              LSLS     r0,r5,#16
0003d2  0231              LSLS     r1,r6,#8
0003d4  4308              ORRS     r0,r0,r1
0003d6  4338              ORRS     r0,r0,r7
0003d8  4604              MOV      r4,r0
;;;433    
;;;434      return Temp;
0003da  4620              MOV      r0,r4
;;;435    }
0003dc  bdf8              POP      {r3-r7,pc}
;;;436    
                          ENDP

                  SPI_FLASH_ReadDeviceID PROC
;;;441      */
;;;442    uint32_t SPI_FLASH_ReadDeviceID(void)
0003de  b510              PUSH     {r4,lr}
;;;443    {
;;;444      uint32_t Temp = 0;
0003e0  2400              MOVS     r4,#0
;;;445    
;;;446      /* Select the FLASH: Chip Select low */
;;;447      SPI_FLASH_CS_LOW();
0003e2  20ff              MOVS     r0,#0xff
0003e4  3001              ADDS     r0,#1
0003e6  4907              LDR      r1,|L1.1028|
0003e8  6288              STR      r0,[r1,#0x28]
;;;448    
;;;449      /* Send "RDID " instruction */
;;;450      SPI_RW_Byte(W25X_DeviceID);
0003ea  20ab              MOVS     r0,#0xab
0003ec  f7fffffe          BL       SPI_RW_Byte
;;;451      SPI_RW_Byte(Dummy_Byte);
0003f0  20ff              MOVS     r0,#0xff
0003f2  f7fffffe          BL       SPI_RW_Byte
;;;452      SPI_RW_Byte(Dummy_Byte);
0003f6  20ff              MOVS     r0,#0xff
0003f8  f7fffffe          BL       SPI_RW_Byte
;;;453      SPI_RW_Byte(Dummy_Byte);
0003fc  20ff              MOVS     r0,#0xff
0003fe  e013              B        |L1.1064|
                  |L1.1024|
                          DCD      0x40004000
                  |L1.1028|
                          DCD      0x400b6000
                  |L1.1032|
000408  5350495f          DCB      "SPI_FLASH_PageWrite too large!",0
00040c  464c4153
000410  485f5061
000414  67655772
000418  69746520
00041c  746f6f20
000420  6c617267
000424  652100  
000427  00                DCB      0
                  |L1.1064|
000428  f7fffffe          BL       SPI_RW_Byte
;;;454      
;;;455      /* Read a byte from the FLASH */
;;;456      Temp = SPI_RW_Byte(Dummy_Byte);
00042c  20ff              MOVS     r0,#0xff
00042e  f7fffffe          BL       SPI_RW_Byte
000432  4604              MOV      r4,r0
;;;457    
;;;458      /* Deselect the FLASH: Chip Select high */
;;;459      SPI_FLASH_CS_HIGH();
000434  20ff              MOVS     r0,#0xff
000436  3001              ADDS     r0,#1
000438  490e              LDR      r1,|L1.1140|
00043a  6248              STR      r0,[r1,#0x24]
;;;460    
;;;461      return Temp;
00043c  4620              MOV      r0,r4
;;;462    }
00043e  bd10              POP      {r4,pc}
;;;463    /*******************************************************************************
                          ENDP

                  SPI_FLASH_StartReadSequence PROC
;;;474    *******************************************************************************/
;;;475    void SPI_FLASH_StartReadSequence(uint32_t ReadAddr)
000440  b510              PUSH     {r4,lr}
;;;476    {
000442  4604              MOV      r4,r0
;;;477      /* Select the FLASH: Chip Select low */
;;;478      SPI_FLASH_CS_LOW();
000444  20ff              MOVS     r0,#0xff
000446  3001              ADDS     r0,#1
000448  490a              LDR      r1,|L1.1140|
00044a  6288              STR      r0,[r1,#0x28]
;;;479    
;;;480      /* Send "Read from Memory " instruction */
;;;481      SPI_RW_Byte(W25X_ReadData);
00044c  2003              MOVS     r0,#3
00044e  f7fffffe          BL       SPI_RW_Byte
;;;482    
;;;483      /* Send the 24-bit address of the address to read from -----------------------*/
;;;484      /* Send ReadAddr high nibble address byte */
;;;485      SPI_RW_Byte((ReadAddr & 0xFF0000) >> 16);
000452  21ff              MOVS     r1,#0xff
000454  0409              LSLS     r1,r1,#16
000456  4021              ANDS     r1,r1,r4
000458  0c08              LSRS     r0,r1,#16
00045a  f7fffffe          BL       SPI_RW_Byte
;;;486      /* Send ReadAddr medium nibble address byte */
;;;487      SPI_RW_Byte((ReadAddr& 0xFF00) >> 8);
00045e  21ff              MOVS     r1,#0xff
000460  0209              LSLS     r1,r1,#8
000462  4021              ANDS     r1,r1,r4
000464  0a08              LSRS     r0,r1,#8
000466  f7fffffe          BL       SPI_RW_Byte
;;;488      /* Send ReadAddr low nibble address byte */
;;;489      SPI_RW_Byte(ReadAddr & 0xFF);
00046a  b2e0              UXTB     r0,r4
00046c  f7fffffe          BL       SPI_RW_Byte
;;;490    }
000470  bd10              POP      {r4,pc}
                          ENDP

000472  0000              DCW      0x0000
                  |L1.1140|
                          DCD      0x400b6000

;*** Start embedded assembler ***

#line 1 "User\\spi0\\bsp_spi.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_spi_c_d0586190____REV16|
#line 114 "..\\inc\\core_cmInstr.h"
|__asm___9_bsp_spi_c_d0586190____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_spi_c_d0586190____REVSH|
#line 128
|__asm___9_bsp_spi_c_d0586190____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
