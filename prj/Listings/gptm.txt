; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\gptm.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\gptm.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\driver\inc -I.\src -I.\User -I.\User\led -I.\User\usart -I.\User\timer -I.\User\ir -I.\User\2.4G -I.\User\spi0 -IF:\1708\dock\prj\RTE -I"D:\Program Files (x86)\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM0\Include" -I"D:\Program Files (x86)\Keil_v5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DARMCM0 -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\gptm.crf ..\driver\src\gptm.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GPTM_DeInit PROC
;;;73      ************************************************************************************************************/
;;;74     void GPTM_DeInit(AM_GPTM_TypeDef* GPTMx)
000000  b510              PUSH     {r4,lr}
;;;75     {
000002  4604              MOV      r4,r0
;;;76       if(GPTMx == AM_GPTM0)
000004  48f7              LDR      r0,|L1.996|
000006  4284              CMP      r4,r0
000008  d104              BNE      |L1.20|
;;;77       {
;;;78         RSTCU_APBPerip1Reset(RSTCU_APBRST1_GPTM0, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  1580              ASRS     r0,r0,#22
00000e  f7fffffe          BL       RSTCU_APBPerip1Reset
000012  e016              B        |L1.66|
                  |L1.20|
;;;79       }
;;;80       else if(GPTMx == AM_GPTM1)
000014  48f4              LDR      r0,|L1.1000|
000016  4284              CMP      r4,r0
000018  d104              BNE      |L1.36|
;;;81       {
;;;82         RSTCU_APBPerip1Reset(RSTCU_APBRST1_GPTM1, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  1540              ASRS     r0,r0,#21
00001e  f7fffffe          BL       RSTCU_APBPerip1Reset
000022  e00e              B        |L1.66|
                  |L1.36|
;;;83       }
;;;84     	else if(GPTMx == AM_GPTM2)
000024  48f1              LDR      r0,|L1.1004|
000026  4284              CMP      r4,r0
000028  d104              BNE      |L1.52|
;;;85       {
;;;86         RSTCU_APBPerip1Reset(RSTCU_APBRST1_GPTM2, ENABLE);
00002a  2101              MOVS     r1,#1
00002c  1500              ASRS     r0,r0,#20
00002e  f7fffffe          BL       RSTCU_APBPerip1Reset
000032  e006              B        |L1.66|
                  |L1.52|
;;;87       }
;;;88     	else if(GPTMx == AM_GPTM3)
000034  48ee              LDR      r0,|L1.1008|
000036  4284              CMP      r4,r0
000038  d103              BNE      |L1.66|
;;;89       {
;;;90         RSTCU_APBPerip1Reset(RSTCU_APBRST1_GPTM3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  14c0              ASRS     r0,r0,#19
00003e  f7fffffe          BL       RSTCU_APBPerip1Reset
                  |L1.66|
;;;91       }
;;;92     }
000042  bd10              POP      {r4,pc}
;;;93     
                          ENDP

                  GPTM_TimeBaseInit PROC
;;;99      ************************************************************************************************************/
;;;100    void GPTM_TimeBaseInit(AM_GPTM_TypeDef* GPTMx, GPTM_TimeBaseInitTypeDef* TimeBaseInit)
000044  880b              LDRH     r3,[r1,#0]
;;;101    {
;;;102      /* Set the counter reload value */
;;;103      GPTMx->CRR = TimeBaseInit->CounterReload;
000046  2288              MOVS     r2,#0x88
000048  5013              STR      r3,[r2,r0]
;;;104    
;;;105      /* Set the Prescaler value */
;;;106      GPTMx->PSCR = TimeBaseInit->Prescaler;
00004a  884b              LDRH     r3,[r1,#2]
00004c  2284              MOVS     r2,#0x84
00004e  5013              STR      r3,[r2,r0]
;;;107    
;;;108      /* Select the Counter Mode */
;;;109      GPTMx->CNTCFR &= CNTCFR_CMSEL_MASK;
000050  6802              LDR      r2,[r0,#0]
000052  2303              MOVS     r3,#3
000054  041b              LSLS     r3,r3,#16
000056  439a              BICS     r2,r2,r3
000058  6002              STR      r2,[r0,#0]
;;;110      GPTMx->CNTCFR &= ~CNTCFR_DIR;
00005a  6802              LDR      r2,[r0,#0]
00005c  2301              MOVS     r3,#1
00005e  061b              LSLS     r3,r3,#24
000060  439a              BICS     r2,r2,r3
000062  6002              STR      r2,[r0,#0]
;;;111      GPTMx->CNTCFR |= TimeBaseInit->CounterMode;
000064  6802              LDR      r2,[r0,#0]
000066  684b              LDR      r3,[r1,#4]
000068  431a              ORRS     r2,r2,r3
00006a  6002              STR      r2,[r0,#0]
;;;112    
;;;113      /* To reload the Prescaler value immediatly or next update event */
;;;114      GPTMx->EVGR = TimeBaseInit->PSCReloadTime;
00006c  890a              LDRH     r2,[r1,#8]
00006e  6782              STR      r2,[r0,#0x78]
;;;115    }
000070  4770              BX       lr
;;;116    
                          ENDP

                  GPTM_OutputInit PROC
;;;123     ************************************************************************************************************/
;;;124    void GPTM_OutputInit(AM_GPTM_TypeDef* GPTMx, GPTM_OutputInitTypeDef* OutInit)
000072  b5f8              PUSH     {r3-r7,lr}
;;;125    {
;;;126      vu32 *pOcfr = (vu32*)&GPTMx->CH0OCFR + OutInit->Channel;
000074  780d              LDRB     r5,[r1,#0]
000076  00ad              LSLS     r5,r5,#2
000078  4606              MOV      r6,r0
00007a  3640              ADDS     r6,r6,#0x40
00007c  19aa              ADDS     r2,r5,r6
;;;127      vu32 *pCcr = (vu32*)&GPTMx->CH0CCR + OutInit->Channel;
00007e  780d              LDRB     r5,[r1,#0]
000080  00ad              LSLS     r5,r5,#2
000082  3650              ADDS     r6,r6,#0x50
000084  19af              ADDS     r7,r5,r6
;;;128      vu32 *pAcr = (vu32*)&GPTMx->CH0ACR + OutInit->Channel;
000086  780d              LDRB     r5,[r1,#0]
000088  00ad              LSLS     r5,r5,#2
00008a  3610              ADDS     r6,r6,#0x10
00008c  19ad              ADDS     r5,r5,r6
00008e  9500              STR      r5,[sp,#0]
;;;129      u8 bChPos = OutInit->Channel << 1;
000090  780d              LDRB     r5,[r1,#0]
000092  066d              LSLS     r5,r5,#25
000094  0e2b              LSRS     r3,r5,#24
;;;130      u32 wTmpMask = ~(0x1ul << bChPos);
000096  2501              MOVS     r5,#1
000098  409d              LSLS     r5,r5,r3
00009a  43ec              MVNS     r4,r5
;;;131    
;;;132      /* Disable the Channel */
;;;133      GPTMx->CHCTR &= wTmpMask;
00009c  6d05              LDR      r5,[r0,#0x50]
00009e  4025              ANDS     r5,r5,r4
0000a0  6505              STR      r5,[r0,#0x50]
;;;134    
;;;135      /* Set the Output Compare Polarity */
;;;136      GPTMx->CHPOLR &= wTmpMask;
0000a2  6d45              LDR      r5,[r0,#0x54]
0000a4  4025              ANDS     r5,r5,r4
0000a6  6545              STR      r5,[r0,#0x54]
;;;137      GPTMx->CHPOLR |= (u32)OutInit->Polarity << bChPos;
0000a8  6d45              LDR      r5,[r0,#0x54]
0000aa  7a4e              LDRB     r6,[r1,#9]
0000ac  409e              LSLS     r6,r6,r3
0000ae  4335              ORRS     r5,r5,r6
0000b0  6545              STR      r5,[r0,#0x54]
;;;138    
;;;139      /* Select the Output Compare Mode */
;;;140      *pOcfr &= CHOCFR_CHOM_MASK;
0000b2  6815              LDR      r5,[r2,#0]
0000b4  26ff              MOVS     r6,#0xff
0000b6  3608              ADDS     r6,r6,#8
0000b8  43b5              BICS     r5,r5,r6
0000ba  6015              STR      r5,[r2,#0]
;;;141      *pOcfr |= OutInit->OutputMode;
0000bc  6815              LDR      r5,[r2,#0]
0000be  684e              LDR      r6,[r1,#4]
0000c0  4335              ORRS     r5,r5,r6
0000c2  6015              STR      r5,[r2,#0]
;;;142    
;;;143      /* Set the Capture Compare Register value */
;;;144      *pCcr = OutInit->Compare;
0000c4  894d              LDRH     r5,[r1,#0xa]
0000c6  603d              STR      r5,[r7,#0]
;;;145    
;;;146      /* Set the Asymmetric Compare Register value */
;;;147      *pAcr = OutInit->AsymmetricCompare;
0000c8  898e              LDRH     r6,[r1,#0xc]
0000ca  9d00              LDR      r5,[sp,#0]
0000cc  602e              STR      r6,[r5,#0]
;;;148    
;;;149      /* Set the channel state */
;;;150      GPTMx->CHCTR |= (u32)OutInit->Control << bChPos;
0000ce  6d05              LDR      r5,[r0,#0x50]
0000d0  7a0e              LDRB     r6,[r1,#8]
0000d2  409e              LSLS     r6,r6,r3
0000d4  4335              ORRS     r5,r5,r6
0000d6  6505              STR      r5,[r0,#0x50]
;;;151    }
0000d8  bdf8              POP      {r3-r7,pc}
;;;152    
                          ENDP

                  GPTM_CHPSCConfig PROC
;;;1052    ************************************************************************************************************/
;;;1053   void GPTM_CHPSCConfig(AM_GPTM_TypeDef* GPTMx, GPTM_CH_Enum Channel, GPTM_CHPSC_Enum Psc)
0000da  b530              PUSH     {r4,r5,lr}
;;;1054   {
0000dc  4603              MOV      r3,r0
;;;1055     vu32 *pIcfr = (vu32*)&GPTMx->CH0ICFR + Channel;
0000de  008d              LSLS     r5,r1,#2
0000e0  461c              MOV      r4,r3
0000e2  3420              ADDS     r4,r4,#0x20
0000e4  1928              ADDS     r0,r5,r4
;;;1056   
;;;1057     /* Reset the CHxPSC bits */
;;;1058     *pIcfr &= CHICFR_CHPSC_MASK;
0000e6  6804              LDR      r4,[r0,#0]
0000e8  2503              MOVS     r5,#3
0000ea  04ad              LSLS     r5,r5,#18
0000ec  43ac              BICS     r4,r4,r5
0000ee  6004              STR      r4,[r0,#0]
;;;1059   
;;;1060     /* Set the capture input prescaler value */
;;;1061     *pIcfr |= Psc;
0000f0  6804              LDR      r4,[r0,#0]
0000f2  4314              ORRS     r4,r4,r2
0000f4  6004              STR      r4,[r0,#0]
;;;1062   }
0000f6  bd30              POP      {r4,r5,pc}
;;;1063   
                          ENDP

                  gptm_CHx_Config PROC
;;;1394   static void
;;;1395   gptm_CHx_Config(AM_GPTM_TypeDef* GPTMx, GPTM_CH_Enum Ch, GPTM_CHP_Enum Pol, GPTM_CHCCS_Enum Sel, u8 Filter)
0000f8  b5ff              PUSH     {r0-r7,lr}
;;;1396   {
;;;1397     vu32* pIcfr = (vu32*)&GPTMx->CH0ICFR + Ch;
0000fa  008e              LSLS     r6,r1,#2
0000fc  4605              MOV      r5,r0
0000fe  3520              ADDS     r5,r5,#0x20
000100  1974              ADDS     r4,r6,r5
;;;1398     u32 wIcfr, wChpolr;
;;;1399   
;;;1400     /* Disable the channel N: reset the CHxE bit */
;;;1401     GPTMx->CHCTR &= ~((u32)0x1 << (Ch << 1));
000102  6d05              LDR      r5,[r0,#0x50]
000104  004f              LSLS     r7,r1,#1
000106  2601              MOVS     r6,#1
000108  40be              LSLS     r6,r6,r7
00010a  43b5              BICS     r5,r5,r6
00010c  6505              STR      r5,[r0,#0x50]
;;;1402   
;;;1403     wIcfr = *pIcfr;
00010e  6822              LDR      r2,[r4,#0]
;;;1404     wChpolr = GPTMx->CHPOLR;
000110  6d43              LDR      r3,[r0,#0x54]
;;;1405   
;;;1406     /* Select the input and set the filter */
;;;1407     wIcfr &= CHICFR_CHCCS_MASK & CHICFR_CHF_MASK;
000112  4db8              LDR      r5,|L1.1012|
000114  402a              ANDS     r2,r2,r5
;;;1408     wIcfr |= Sel | Filter;
000116  9e09              LDR      r6,[sp,#0x24]
000118  9d03              LDR      r5,[sp,#0xc]
00011a  4335              ORRS     r5,r5,r6
00011c  432a              ORRS     r2,r2,r5
;;;1409     *pIcfr = wIcfr;
00011e  6022              STR      r2,[r4,#0]
;;;1410   
;;;1411     /* Select the polarity bit */
;;;1412     wChpolr &= ~((u32)0x1 << (Ch << 1));
000120  004e              LSLS     r6,r1,#1
000122  2501              MOVS     r5,#1
000124  40b5              LSLS     r5,r5,r6
000126  461e              MOV      r6,r3
000128  43ae              BICS     r6,r6,r5
00012a  4633              MOV      r3,r6
;;;1413     wChpolr |= (u32)Pol << (Ch << 1);
00012c  004e              LSLS     r6,r1,#1
00012e  9d02              LDR      r5,[sp,#8]
000130  40b5              LSLS     r5,r5,r6
000132  432b              ORRS     r3,r3,r5
;;;1414     GPTMx->CHPOLR = wChpolr;
000134  6543              STR      r3,[r0,#0x54]
;;;1415   
;;;1416     /* Set the CHxE Bit */
;;;1417     GPTMx->CHCTR |= (u32)0x1 << (Ch << 1);
000136  6d05              LDR      r5,[r0,#0x50]
000138  004f              LSLS     r7,r1,#1
00013a  2601              MOVS     r6,#1
00013c  40be              LSLS     r6,r6,r7
00013e  4335              ORRS     r5,r5,r6
000140  6505              STR      r5,[r0,#0x50]
;;;1418   }
000142  bdff              POP      {r0-r7,pc}
;;;1419   
                          ENDP

                  GPTM_CaptureInit PROC
;;;159     ************************************************************************************************************/
;;;160    void GPTM_CaptureInit(AM_GPTM_TypeDef* GPTMx, GPTM_CaptureInitTypeDef* CapInit)
000144  b538              PUSH     {r3-r5,lr}
;;;161    {
000146  4605              MOV      r5,r0
000148  460c              MOV      r4,r1
;;;162      gptm_CHx_Config(GPTMx, CapInit->Channel, CapInit->Polarity, CapInit->Selection, CapInit->Filter);
00014a  7b20              LDRB     r0,[r4,#0xc]
00014c  9000              STR      r0,[sp,#0]
00014e  7862              LDRB     r2,[r4,#1]
000150  7821              LDRB     r1,[r4,#0]
000152  4628              MOV      r0,r5
000154  6863              LDR      r3,[r4,#4]
000156  f7fffffe          BL       gptm_CHx_Config
;;;163    
;;;164      /* Set the Input Capture Prescaler value */
;;;165      GPTM_CHPSCConfig(GPTMx, CapInit->Channel, CapInit->Prescaler);
00015a  7821              LDRB     r1,[r4,#0]
00015c  4628              MOV      r0,r5
00015e  68a2              LDR      r2,[r4,#8]
000160  f7fffffe          BL       GPTM_CHPSCConfig
;;;166    }
000164  bd38              POP      {r3-r5,pc}
;;;167    
                          ENDP

                  GPTM_PwmInputInit PROC
;;;174     ************************************************************************************************************/
;;;175    void GPTM_PwmInputInit(AM_GPTM_TypeDef* GPTMx, GPTM_CaptureInitTypeDef* CapInit)
000166  b5f8              PUSH     {r3-r7,lr}
;;;176    {
000168  4605              MOV      r5,r0
00016a  460c              MOV      r4,r1
;;;177      GPTM_CHP_Enum OppositePol = GPTM_CHP_NONINVERTED;
00016c  2600              MOVS     r6,#0
;;;178      GPTM_CHCCS_Enum OppositeSel = GPTM_CHCCS_DIRECT;
00016e  2701              MOVS     r7,#1
000170  043f              LSLS     r7,r7,#16
;;;179    
;;;180      /* Select the Opposite Input Polarity */
;;;181      if (CapInit->Polarity == GPTM_CHP_NONINVERTED)
000172  7860              LDRB     r0,[r4,#1]
000174  2800              CMP      r0,#0
000176  d101              BNE      |L1.380|
;;;182      {
;;;183        OppositePol = GPTM_CHP_INVERTED;
000178  2601              MOVS     r6,#1
00017a  e000              B        |L1.382|
                  |L1.380|
;;;184      }
;;;185      else
;;;186      {
;;;187        OppositePol = GPTM_CHP_NONINVERTED;
00017c  2600              MOVS     r6,#0
                  |L1.382|
;;;188      }
;;;189    
;;;190      /* Select the Opposite Input */
;;;191      if (CapInit->Selection == GPTM_CHCCS_DIRECT)
00017e  2101              MOVS     r1,#1
000180  0409              LSLS     r1,r1,#16
000182  6860              LDR      r0,[r4,#4]
000184  4288              CMP      r0,r1
000186  d101              BNE      |L1.396|
;;;192      {
;;;193        OppositeSel = GPTM_CHCCS_INDIRECT;
000188  0047              LSLS     r7,r0,#1
00018a  e001              B        |L1.400|
                  |L1.396|
;;;194      }
;;;195      else
;;;196      {
;;;197        OppositeSel = GPTM_CHCCS_DIRECT;
00018c  2701              MOVS     r7,#1
00018e  043f              LSLS     r7,r7,#16
                  |L1.400|
;;;198      }
;;;199    
;;;200      if (CapInit->Channel == GPTM_CH_0)
000190  7820              LDRB     r0,[r4,#0]
000192  2800              CMP      r0,#0
000194  d11a              BNE      |L1.460|
;;;201      {
;;;202        /* CH0 Configuration */
;;;203        gptm_CHx_Config(GPTMx, GPTM_CH_0, CapInit->Polarity, CapInit->Selection, CapInit->Filter);
000196  7b20              LDRB     r0,[r4,#0xc]
000198  9000              STR      r0,[sp,#0]
00019a  7862              LDRB     r2,[r4,#1]
00019c  2100              MOVS     r1,#0
00019e  4628              MOV      r0,r5
0001a0  6863              LDR      r3,[r4,#4]
0001a2  f7fffffe          BL       gptm_CHx_Config
;;;204    
;;;205        /* Set the Input Capture Prescaler value */
;;;206        GPTM_CHPSCConfig(GPTMx, GPTM_CH_0, CapInit->Prescaler);
0001a6  2100              MOVS     r1,#0
0001a8  4628              MOV      r0,r5
0001aa  68a2              LDR      r2,[r4,#8]
0001ac  f7fffffe          BL       GPTM_CHPSCConfig
;;;207    
;;;208        /* CH1 Configuration */
;;;209        gptm_CHx_Config(GPTMx, GPTM_CH_1, OppositePol, OppositeSel, CapInit->Filter);
0001b0  7b20              LDRB     r0,[r4,#0xc]
0001b2  463b              MOV      r3,r7
0001b4  4632              MOV      r2,r6
0001b6  2101              MOVS     r1,#1
0001b8  9000              STR      r0,[sp,#0]
0001ba  4628              MOV      r0,r5
0001bc  f7fffffe          BL       gptm_CHx_Config
;;;210    
;;;211        /* Set the Input Capture Prescaler value */
;;;212        GPTM_CHPSCConfig(GPTMx, GPTM_CH_1, CapInit->Prescaler);
0001c0  2101              MOVS     r1,#1
0001c2  4628              MOV      r0,r5
0001c4  68a2              LDR      r2,[r4,#8]
0001c6  f7fffffe          BL       GPTM_CHPSCConfig
0001ca  e019              B        |L1.512|
                  |L1.460|
;;;213      }
;;;214      else
;;;215      {
;;;216        /* CH1 Configuration */
;;;217        gptm_CHx_Config(GPTMx, GPTM_CH_1, CapInit->Polarity, CapInit->Selection, CapInit->Filter);
0001cc  7b20              LDRB     r0,[r4,#0xc]
0001ce  9000              STR      r0,[sp,#0]
0001d0  7862              LDRB     r2,[r4,#1]
0001d2  2101              MOVS     r1,#1
0001d4  4628              MOV      r0,r5
0001d6  6863              LDR      r3,[r4,#4]
0001d8  f7fffffe          BL       gptm_CHx_Config
;;;218    
;;;219        /* Set the Input Capture Prescaler value */
;;;220        GPTM_CHPSCConfig(GPTMx, GPTM_CH_1, CapInit->Prescaler);
0001dc  2101              MOVS     r1,#1
0001de  4628              MOV      r0,r5
0001e0  68a2              LDR      r2,[r4,#8]
0001e2  f7fffffe          BL       GPTM_CHPSCConfig
;;;221    
;;;222        /* CH0 Configuration */
;;;223        gptm_CHx_Config(GPTMx, GPTM_CH_0, OppositePol, OppositeSel, CapInit->Filter);
0001e6  7b20              LDRB     r0,[r4,#0xc]
0001e8  463b              MOV      r3,r7
0001ea  4632              MOV      r2,r6
0001ec  2100              MOVS     r1,#0
0001ee  9000              STR      r0,[sp,#0]
0001f0  4628              MOV      r0,r5
0001f2  f7fffffe          BL       gptm_CHx_Config
;;;224    
;;;225        /* Set the Input Capture Prescaler value */
;;;226        GPTM_CHPSCConfig(GPTMx, GPTM_CH_0, CapInit->Prescaler);
0001f6  2100              MOVS     r1,#0
0001f8  4628              MOV      r0,r5
0001fa  68a2              LDR      r2,[r4,#8]
0001fc  f7fffffe          BL       GPTM_CHPSCConfig
                  |L1.512|
;;;227      }
;;;228    }
000200  bdf8              POP      {r3-r7,pc}
;;;229    
                          ENDP

                  GPTM_TimeBaseStructInit PROC
;;;234     ************************************************************************************************************/
;;;235    void GPTM_TimeBaseStructInit(GPTM_TimeBaseInitTypeDef* TimeBaseInit)
000202  2100              MOVS     r1,#0
;;;236    {
;;;237      /* Set the default configuration */
;;;238      TimeBaseInit->CounterMode = GPTM_CNT_MODE_UP;
000204  6041              STR      r1,[r0,#4]
;;;239      TimeBaseInit->CounterReload = 0xFFFF;
000206  1e49              SUBS     r1,r1,#1
000208  8001              STRH     r1,[r0,#0]
;;;240      TimeBaseInit->Prescaler = 0x0000;
00020a  2100              MOVS     r1,#0
00020c  8041              STRH     r1,[r0,#2]
;;;241      TimeBaseInit->PSCReloadTime = GPTM_PSC_RLD_IMMEDIATE;
00020e  21ff              MOVS     r1,#0xff
000210  3101              ADDS     r1,#1
000212  8101              STRH     r1,[r0,#8]
;;;242    }
000214  4770              BX       lr
;;;243    
                          ENDP

                  GPTM_OutputStructInit PROC
;;;248     ************************************************************************************************************/
;;;249    void GPTM_OutputStructInit(GPTM_OutputInitTypeDef* OutInit)
000216  2100              MOVS     r1,#0
;;;250    {
;;;251      /* Set the default configuration */
;;;252      OutInit->Channel = GPTM_CH_0;
000218  7001              STRB     r1,[r0,#0]
;;;253      OutInit->OutputMode = GPTM_OM_MATCH_NOCHANGE;
00021a  6041              STR      r1,[r0,#4]
;;;254      OutInit->Control = GPTM_CHCTL_DISABLE;
00021c  7201              STRB     r1,[r0,#8]
;;;255      OutInit->Polarity = GPTM_CHP_NONINVERTED;
00021e  7241              STRB     r1,[r0,#9]
;;;256      OutInit->Compare = 0x0000;
000220  8141              STRH     r1,[r0,#0xa]
;;;257      OutInit->AsymmetricCompare = 0x0000;
000222  8181              STRH     r1,[r0,#0xc]
;;;258    }
000224  4770              BX       lr
;;;259    
                          ENDP

                  GPTM_CaptureStructInit PROC
;;;264     ************************************************************************************************************/
;;;265    void GPTM_CaptureStructInit(GPTM_CaptureInitTypeDef* CapInit)
000226  2100              MOVS     r1,#0
;;;266    {
;;;267      /* Set the default configuration */
;;;268      CapInit->Channel = GPTM_CH_0;
000228  7001              STRB     r1,[r0,#0]
;;;269      CapInit->Polarity = GPTM_CHP_NONINVERTED;
00022a  7041              STRB     r1,[r0,#1]
;;;270      CapInit->Selection = GPTM_CHCCS_DIRECT;
00022c  2101              MOVS     r1,#1
00022e  0409              LSLS     r1,r1,#16
000230  6041              STR      r1,[r0,#4]
;;;271      CapInit->Prescaler = GPTM_CHPSC_OFF;
000232  2100              MOVS     r1,#0
000234  6081              STR      r1,[r0,#8]
;;;272      CapInit->Filter = 0x00;
000236  7301              STRB     r1,[r0,#0xc]
;;;273    }
000238  4770              BX       lr
;;;274    
                          ENDP

                  GPTM_Cmd PROC
;;;280     ************************************************************************************************************/
;;;281    void GPTM_Cmd(AM_GPTM_TypeDef* GPTMx, ControlStatus NewState)
00023a  2900              CMP      r1,#0
;;;282    {
;;;283      if (NewState != DISABLE)
00023c  d004              BEQ      |L1.584|
;;;284      {
;;;285        /* Enable the GPTM Counter */
;;;286        GPTMx->CTR |= CTR_TME;
00023e  6902              LDR      r2,[r0,#0x10]
000240  2301              MOVS     r3,#1
000242  431a              ORRS     r2,r2,r3
000244  6102              STR      r2,[r0,#0x10]
000246  e003              B        |L1.592|
                  |L1.584|
;;;287      }
;;;288      else
;;;289      {
;;;290        /* Disable the GPTM Counter */
;;;291        GPTMx->CTR &= ~CTR_TME;
000248  6902              LDR      r2,[r0,#0x10]
00024a  0852              LSRS     r2,r2,#1
00024c  0052              LSLS     r2,r2,#1
00024e  6102              STR      r2,[r0,#0x10]
                  |L1.592|
;;;292      }
;;;293    }
000250  4770              BX       lr
;;;294    
                          ENDP

                  GPTM_StiConfig PROC
;;;461     ************************************************************************************************************/
;;;462    void GPTM_StiConfig(AM_GPTM_TypeDef* GPTMx, GPTM_TRSEL_Enum Sel)
000252  b510              PUSH     {r4,lr}
;;;463    {
;;;464      u32 wTrcfr;
;;;465    
;;;466      /* Disable slave mode */
;;;467      GPTMx->MDCFR &= MDCFR_SMSEL_MASK;
000254  6843              LDR      r3,[r0,#4]
000256  2407              MOVS     r4,#7
000258  0224              LSLS     r4,r4,#8
00025a  43a3              BICS     r3,r3,r4
00025c  6043              STR      r3,[r0,#4]
;;;468    
;;;469      /* Get the TRCFR value with cleared TRSEL */
;;;470      wTrcfr = GPTMx->TRCFR & TRCFR_TRSEL_MASK;
00025e  6883              LDR      r3,[r0,#8]
000260  091a              LSRS     r2,r3,#4
000262  0112              LSLS     r2,r2,#4
;;;471    
;;;472      /* Set the STI source */
;;;473      GPTMx->TRCFR |= wTrcfr | Sel;
000264  6883              LDR      r3,[r0,#8]
000266  4614              MOV      r4,r2
000268  430c              ORRS     r4,r4,r1
00026a  4323              ORRS     r3,r3,r4
00026c  6083              STR      r3,[r0,#8]
;;;474    }
00026e  bd10              POP      {r4,pc}
;;;475    
                          ENDP

                  GPTM_ItiExternalClockConfig PROC
;;;304     ************************************************************************************************************/
;;;305    void GPTM_ItiExternalClockConfig(AM_GPTM_TypeDef* GPTMx, GPTM_TRSEL_Enum Iti)
000270  b530              PUSH     {r4,r5,lr}
;;;306    {
000272  4604              MOV      r4,r0
000274  460d              MOV      r5,r1
;;;307      /* Select the Internal Trigger. Slave mode will be disable in this function*/
;;;308      GPTM_StiConfig(GPTMx, Iti);
000276  4629              MOV      r1,r5
000278  4620              MOV      r0,r4
00027a  f7fffffe          BL       GPTM_StiConfig
;;;309    
;;;310      /* Select the STIED as external clock source */
;;;311      GPTMx->MDCFR |= GPTM_SMSEL_STIED;
00027e  6860              LDR      r0,[r4,#4]
000280  2107              MOVS     r1,#7
000282  0209              LSLS     r1,r1,#8
000284  4308              ORRS     r0,r0,r1
000286  6060              STR      r0,[r4,#4]
;;;312    }
000288  bd30              POP      {r4,r5,pc}
;;;313    
                          ENDP

                  GPTM_ChExternalClockConfig PROC
;;;329     ************************************************************************************************************/
;;;330    void GPTM_ChExternalClockConfig(AM_GPTM_TypeDef* GPTMx, GPTM_TRSEL_Enum Sel, GPTM_CHP_Enum Pol, u8 Filter)
00028a  b5f8              PUSH     {r3-r7,lr}
;;;331    {
00028c  4604              MOV      r4,r0
00028e  460e              MOV      r6,r1
000290  4617              MOV      r7,r2
000292  461d              MOV      r5,r3
;;;332      /* Configure the Timer Input Clock Source */
;;;333      if (Sel == GPTM_TRSEL_TI1S1)
000294  2e02              CMP      r6,#2
000296  d107              BNE      |L1.680|
;;;334      {
;;;335        gptm_CHx_Config(GPTMx, GPTM_CH_1, Pol, GPTM_CHCCS_DIRECT, Filter);
000298  03cb              LSLS     r3,r1,#15
00029a  463a              MOV      r2,r7
00029c  2101              MOVS     r1,#1
00029e  4620              MOV      r0,r4
0002a0  9500              STR      r5,[sp,#0]
0002a2  f7fffffe          BL       gptm_CHx_Config
0002a6  e007              B        |L1.696|
                  |L1.680|
;;;336      }
;;;337      else
;;;338      {
;;;339        gptm_CHx_Config(GPTMx, GPTM_CH_0, Pol, GPTM_CHCCS_DIRECT, Filter);
0002a8  2301              MOVS     r3,#1
0002aa  041b              LSLS     r3,r3,#16
0002ac  463a              MOV      r2,r7
0002ae  2100              MOVS     r1,#0
0002b0  4620              MOV      r0,r4
0002b2  9500              STR      r5,[sp,#0]
0002b4  f7fffffe          BL       gptm_CHx_Config
                  |L1.696|
;;;340      }
;;;341    
;;;342      /* Select the external clock source. Slave mode will be disable in this function */
;;;343      GPTM_StiConfig(GPTMx, Sel);
0002b8  4631              MOV      r1,r6
0002ba  4620              MOV      r0,r4
0002bc  f7fffffe          BL       GPTM_StiConfig
;;;344    
;;;345      /* Select the STIED as external clock source */
;;;346      GPTMx->MDCFR |= GPTM_SMSEL_STIED;
0002c0  6860              LDR      r0,[r4,#4]
0002c2  2107              MOVS     r1,#7
0002c4  0209              LSLS     r1,r1,#8
0002c6  4308              ORRS     r0,r0,r1
0002c8  6060              STR      r0,[r4,#4]
;;;347    }
0002ca  bdf8              POP      {r3-r7,pc}
;;;348    
                          ENDP

                  GPTM_EtiConfig PROC
;;;391     ************************************************************************************************************/
;;;392    void GPTM_EtiConfig(AM_GPTM_TypeDef* GPTMx, GPTM_ETIPSC_Enum Psc, GPTM_ETIPOL_Enum Pol, u8 Filter)
0002cc  b570              PUSH     {r4-r6,lr}
;;;393    {
;;;394      u32 wTrcfr;
;;;395    
;;;396      /* Get TRCFR value with cleared ETI configuration bits */
;;;397      wTrcfr = GPTMx->TRCFR & TRCFR_ETI_CONF_MASK;
0002ce  6885              LDR      r5,[r0,#8]
0002d0  4e49              LDR      r6,|L1.1016|
0002d2  4035              ANDS     r5,r5,r6
0002d4  462c              MOV      r4,r5
;;;398    
;;;399      /* Set the prescaler, filter and polarity for ETI inpit */
;;;400      wTrcfr |= (u32)Psc | Pol | ((u32)Filter << 8);
0002d6  460d              MOV      r5,r1
0002d8  4315              ORRS     r5,r5,r2
0002da  021e              LSLS     r6,r3,#8
0002dc  4335              ORRS     r5,r5,r6
0002de  432c              ORRS     r4,r4,r5
;;;401    
;;;402      /* Write to GPTMx TRCFR */
;;;403      GPTMx->TRCFR = wTrcfr;
0002e0  6084              STR      r4,[r0,#8]
;;;404    }
0002e2  bd70              POP      {r4-r6,pc}
;;;405    
                          ENDP

                  GPTM_EtiExternalClockConfig PROC
;;;365     ************************************************************************************************************/
;;;366    void GPTM_EtiExternalClockConfig(AM_GPTM_TypeDef* GPTMx, GPTM_ETIPSC_Enum Psc, GPTM_ETIPOL_Enum Pol, u8 Filter)
0002e4  b5f0              PUSH     {r4-r7,lr}
;;;367    {
0002e6  4604              MOV      r4,r0
0002e8  460d              MOV      r5,r1
0002ea  4616              MOV      r6,r2
0002ec  461f              MOV      r7,r3
;;;368      /* Configure the ETI Clock source */
;;;369      GPTM_EtiConfig(GPTMx, Psc, Pol, Filter);
0002ee  463b              MOV      r3,r7
0002f0  4632              MOV      r2,r6
0002f2  4629              MOV      r1,r5
0002f4  4620              MOV      r0,r4
0002f6  f7fffffe          BL       GPTM_EtiConfig
;;;370    
;;;371      /* Enable the external clock mode */
;;;372      GPTMx->TRCFR |= TRCFR_ECME;
0002fa  68a0              LDR      r0,[r4,#8]
0002fc  2101              MOVS     r1,#1
0002fe  0609              LSLS     r1,r1,#24
000300  4308              ORRS     r0,r0,r1
000302  60a0              STR      r0,[r4,#8]
;;;373    }
000304  bdf0              POP      {r4-r7,pc}
;;;374    
                          ENDP

                  GPTM_PrescalerConfig PROC
;;;415     ************************************************************************************************************/
;;;416    void GPTM_PrescalerConfig(AM_GPTM_TypeDef* GPTMx, u16 Psc, GPTM_PSC_RLD_Enum PscReloadTime)
000306  2384              MOVS     r3,#0x84
;;;417    {
;;;418      /* Set the prescaler value */
;;;419      GPTMx->PSCR = Psc;
000308  5019              STR      r1,[r3,r0]
;;;420    
;;;421      /* Set the UEVG bit or not */
;;;422      GPTMx->EVGR = PscReloadTime;
00030a  6782              STR      r2,[r0,#0x78]
;;;423    }
00030c  4770              BX       lr
;;;424    
                          ENDP

                  GPTM_CounterModeConfig PROC
;;;436     ************************************************************************************************************/
;;;437    void GPTM_CounterModeConfig(AM_GPTM_TypeDef* GPTMx, GPTM_CNT_MODE_Enum Mod)
00030e  6802              LDR      r2,[r0,#0]
;;;438    {
;;;439      /* Reset the CMSEL and DIR Bits */
;;;440      GPTMx->CNTCFR &= CNTCFR_CMSEL_MASK;
000310  2303              MOVS     r3,#3
000312  041b              LSLS     r3,r3,#16
000314  439a              BICS     r2,r2,r3
000316  6002              STR      r2,[r0,#0]
;;;441      GPTMx->CNTCFR &= ~CNTCFR_DIR;
000318  6802              LDR      r2,[r0,#0]
00031a  2301              MOVS     r3,#1
00031c  061b              LSLS     r3,r3,#24
00031e  439a              BICS     r2,r2,r3
000320  6002              STR      r2,[r0,#0]
;;;442    
;;;443      /* Set the Counter Mode */
;;;444      GPTMx->CNTCFR |= Mod;
000322  6802              LDR      r2,[r0,#0]
000324  430a              ORRS     r2,r2,r1
000326  6002              STR      r2,[r0,#0]
;;;445    }
000328  4770              BX       lr
;;;446    
                          ENDP

                  GPTM_DecoderConfig PROC
;;;494     ************************************************************************************************************/
;;;495    void GPTM_DecoderConfig(AM_GPTM_TypeDef* GPTMx, GPTM_SMSEL_Enum DecoderMod,
00032a  b5ff              PUSH     {r0-r7,lr}
;;;496                            GPTM_CHP_Enum CH0P, GPTM_CHP_Enum CH1P)
;;;497    {
00032c  460c              MOV      r4,r1
;;;498      u32 wMdcfr, wCh0Icfr, wCh1Icfr, wChpolr;
;;;499    
;;;500      /* Get the GPTMx MDCFR register value */
;;;501      wMdcfr = GPTMx->MDCFR;
00032e  6841              LDR      r1,[r0,#4]
;;;502    
;;;503      /* Get the GPTMx CH0ICFR & CH1ICFR register value */
;;;504      wCh0Icfr = GPTMx->CH0ICFR;
000330  6a02              LDR      r2,[r0,#0x20]
;;;505      wCh1Icfr = GPTMx->CH1ICFR;
000332  6a45              LDR      r5,[r0,#0x24]
;;;506    
;;;507      /* Get the GPTMx CHPOLR register value */
;;;508      wChpolr = GPTMx->CHPOLR;
000334  6d43              LDR      r3,[r0,#0x54]
;;;509    
;;;510      /* Set the decoder mode */
;;;511      wMdcfr &= MDCFR_SMSEL_MASK;
000336  2607              MOVS     r6,#7
000338  0236              LSLS     r6,r6,#8
00033a  460f              MOV      r7,r1
00033c  43b7              BICS     r7,r7,r6
00033e  4639              MOV      r1,r7
;;;512      wMdcfr |= DecoderMod;
000340  460e              MOV      r6,r1
000342  4326              ORRS     r6,r6,r4
000344  4631              MOV      r1,r6
;;;513    
;;;514      /* Select the channel 0 and the channel 1 as input and clear CH0SRC */
;;;515      wCh0Icfr &= CHICFR_CHCCS_MASK & (~CH0ICFR_CH0SRC);
000346  4e2d              LDR      r6,|L1.1020|
000348  4032              ANDS     r2,r2,r6
;;;516      wCh1Icfr &= CHICFR_CHCCS_MASK;
00034a  2603              MOVS     r6,#3
00034c  0436              LSLS     r6,r6,#16
00034e  462f              MOV      r7,r5
000350  43b7              BICS     r7,r7,r6
000352  463d              MOV      r5,r7
;;;517      wCh0Icfr |= GPTM_CHCCS_DIRECT;
000354  2601              MOVS     r6,#1
000356  0436              LSLS     r6,r6,#16
000358  4332              ORRS     r2,r2,r6
;;;518      wCh1Icfr |= GPTM_CHCCS_DIRECT;
00035a  4335              ORRS     r5,r5,r6
;;;519    
;;;520      /* Set the CH0 and the CH1 polarities */
;;;521      wChpolr &= ~(CHPOLR_CH0P | CHPOLR_CH1P);
00035c  2605              MOVS     r6,#5
00035e  461f              MOV      r7,r3
000360  43b7              BICS     r7,r7,r6
000362  463b              MOV      r3,r7
;;;522      wChpolr |= (CH0P | (CH1P << 2));
000364  9e03              LDR      r6,[sp,#0xc]
000366  00b6              LSLS     r6,r6,#2
000368  9f02              LDR      r7,[sp,#8]
00036a  433e              ORRS     r6,r6,r7
00036c  4333              ORRS     r3,r3,r6
;;;523    
;;;524      /* Write to GPTMx MDCFR */
;;;525      GPTMx->MDCFR = wMdcfr;
00036e  6041              STR      r1,[r0,#4]
;;;526    
;;;527      /* Write to GPTMx CH0ICFR & CH1ICFR */
;;;528      GPTMx->CH0ICFR = wCh0Icfr;
000370  6202              STR      r2,[r0,#0x20]
;;;529      GPTMx->CH1ICFR = wCh1Icfr;
000372  6245              STR      r5,[r0,#0x24]
;;;530    
;;;531      /* Write to GPTMx CHPOLR */
;;;532      GPTMx->CHPOLR = wChpolr;
000374  6543              STR      r3,[r0,#0x54]
;;;533    }
000376  bdff              POP      {r0-r7,pc}
;;;534    
                          ENDP

                  GPTM_ForcedOREF0 PROC
;;;543     ************************************************************************************************************/
;;;544    void GPTM_ForcedOREF0(AM_GPTM_TypeDef* GPTMx, u32 ForcedAction)
000378  6c02              LDR      r2,[r0,#0x40]
;;;545    {
;;;546      /* Configure The forced output mode */
;;;547      GPTMx->CH0OCFR = (GPTMx->CH0OCFR & CHOCFR_CHOM_MASK) | ForcedAction;
00037a  23ff              MOVS     r3,#0xff
00037c  3308              ADDS     r3,r3,#8
00037e  439a              BICS     r2,r2,r3
000380  430a              ORRS     r2,r2,r1
000382  6402              STR      r2,[r0,#0x40]
;;;548    }
000384  4770              BX       lr
;;;549    
                          ENDP

                  GPTM_ForcedOREF1 PROC
;;;558     ************************************************************************************************************/
;;;559    void GPTM_ForcedOREF1(AM_GPTM_TypeDef* GPTMx, u32 ForcedAction)
000386  6c42              LDR      r2,[r0,#0x44]
;;;560    {
;;;561      /* Configure The forced output mode */
;;;562      GPTMx->CH1OCFR = (GPTMx->CH1OCFR & CHOCFR_CHOM_MASK) | ForcedAction;
000388  23ff              MOVS     r3,#0xff
00038a  3308              ADDS     r3,r3,#8
00038c  439a              BICS     r2,r2,r3
00038e  430a              ORRS     r2,r2,r1
000390  6442              STR      r2,[r0,#0x44]
;;;563    }
000392  4770              BX       lr
;;;564    
                          ENDP

                  GPTM_ForcedOREF2 PROC
;;;573     ************************************************************************************************************/
;;;574    void GPTM_ForcedOREF2(AM_GPTM_TypeDef* GPTMx, u32 ForcedAction)
000394  6c82              LDR      r2,[r0,#0x48]
;;;575    {
;;;576      /* Configure The forced output mode */
;;;577      GPTMx->CH2OCFR = (GPTMx->CH2OCFR & CHOCFR_CHOM_MASK) | ForcedAction;
000396  23ff              MOVS     r3,#0xff
000398  3308              ADDS     r3,r3,#8
00039a  439a              BICS     r2,r2,r3
00039c  430a              ORRS     r2,r2,r1
00039e  6482              STR      r2,[r0,#0x48]
;;;578    }
0003a0  4770              BX       lr
;;;579    
                          ENDP

                  GPTM_ForcedOREF3 PROC
;;;588     ************************************************************************************************************/
;;;589    void GPTM_ForcedOREF3(AM_GPTM_TypeDef* GPTMx, u32 ForcedAction)
0003a2  6cc2              LDR      r2,[r0,#0x4c]
;;;590    {
;;;591      /* Configure The forced output mode */
;;;592      GPTMx->CH3OCFR = (GPTMx->CH3OCFR & CHOCFR_CHOM_MASK) | ForcedAction;
0003a4  23ff              MOVS     r3,#0xff
0003a6  3308              ADDS     r3,r3,#8
0003a8  439a              BICS     r2,r2,r3
0003aa  430a              ORRS     r2,r2,r1
0003ac  64c2              STR      r2,[r0,#0x4c]
;;;593    }
0003ae  4770              BX       lr
;;;594    
                          ENDP

                  GPTM_CRRPreloadCmd PROC
;;;600     ************************************************************************************************************/
;;;601    void GPTM_CRRPreloadCmd(AM_GPTM_TypeDef* GPTMx, ControlStatus NewState)
0003b0  2900              CMP      r1,#0
;;;602    {
;;;603      if (NewState != DISABLE)
0003b2  d004              BEQ      |L1.958|
;;;604      {
;;;605        /* Set the CRR preload control bit */
;;;606        GPTMx->CTR |= CTR_CRBE;
0003b4  6902              LDR      r2,[r0,#0x10]
0003b6  2302              MOVS     r3,#2
0003b8  431a              ORRS     r2,r2,r3
0003ba  6102              STR      r2,[r0,#0x10]
0003bc  e003              B        |L1.966|
                  |L1.958|
;;;607      }
;;;608      else
;;;609      {
;;;610        /* Reset the CRR preload control bit */
;;;611        GPTMx->CTR &= ~CTR_CRBE;
0003be  6902              LDR      r2,[r0,#0x10]
0003c0  2302              MOVS     r3,#2
0003c2  439a              BICS     r2,r2,r3
0003c4  6102              STR      r2,[r0,#0x10]
                  |L1.966|
;;;612      }
;;;613    }
0003c6  4770              BX       lr
;;;614    
                          ENDP

                  GPTM_CHCCRPreloadConfig PROC
;;;626     ************************************************************************************************************/
;;;627    void GPTM_CHCCRPreloadConfig(AM_GPTM_TypeDef* GPTMx, GPTM_CH_Enum Channel, ControlStatus NewState)
0003c8  b530              PUSH     {r4,r5,lr}
;;;628    {
0003ca  4603              MOV      r3,r0
;;;629      vu32 *pOcfr = (vu32*)&GPTMx->CH0OCFR + Channel;
0003cc  008d              LSLS     r5,r1,#2
0003ce  461c              MOV      r4,r3
0003d0  3440              ADDS     r4,r4,#0x40
0003d2  1928              ADDS     r0,r5,r4
;;;630    
;;;631      /* Enable or disable the channel N CCR preload feature */
;;;632      if(NewState != DISABLE)
0003d4  2a00              CMP      r2,#0
0003d6  d013              BEQ      |L1.1024|
;;;633      {
;;;634        *pOcfr |= CHOCFR_CHPRE;
0003d8  6804              LDR      r4,[r0,#0]
0003da  2510              MOVS     r5,#0x10
0003dc  432c              ORRS     r4,r4,r5
0003de  6004              STR      r4,[r0,#0]
0003e0  e012              B        |L1.1032|
0003e2  0000              DCW      0x0000
                  |L1.996|
                          DCD      0x4006e000
                  |L1.1000|
                          DCD      0x4006f000
                  |L1.1004|
                          DCD      0x40070000
                  |L1.1008|
                          DCD      0x40071000
                  |L1.1012|
                          DCD      0xfffcfff0
                  |L1.1016|
                          DCD      0xfffec0ff
                  |L1.1020|
                          DCD      0x7ffcffff
                  |L1.1024|
;;;635      }
;;;636      else
;;;637      {
;;;638        *pOcfr &= ~CHOCFR_CHPRE;
000400  6804              LDR      r4,[r0,#0]
000402  2510              MOVS     r5,#0x10
000404  43ac              BICS     r4,r4,r5
000406  6004              STR      r4,[r0,#0]
                  |L1.1032|
;;;639      }
;;;640    }
000408  bd30              POP      {r4,r5,pc}
;;;641    
                          ENDP

                  GPTM_ClearOREFConfig PROC
;;;653     ************************************************************************************************************/
;;;654    void GPTM_ClearOREFConfig(AM_GPTM_TypeDef* GPTMx, GPTM_CH_Enum Channel, ControlStatus NewState)
00040a  b530              PUSH     {r4,r5,lr}
;;;655    {
00040c  4603              MOV      r3,r0
;;;656      vu32 *pOcfr = (vu32*)&GPTMx->CH0OCFR + Channel;
00040e  008d              LSLS     r5,r1,#2
000410  461c              MOV      r4,r3
000412  3440              ADDS     r4,r4,#0x40
000414  1928              ADDS     r0,r5,r4
;;;657    
;;;658      /* Enable or Disable the channel N clear Oref at ETI active function */
;;;659      if(NewState != DISABLE)
000416  2a00              CMP      r2,#0
000418  d004              BEQ      |L1.1060|
;;;660      {
;;;661        *pOcfr |= CHOCFR_REFCE;
00041a  6804              LDR      r4,[r0,#0]
00041c  2508              MOVS     r5,#8
00041e  432c              ORRS     r4,r4,r5
000420  6004              STR      r4,[r0,#0]
000422  e003              B        |L1.1068|
                  |L1.1060|
;;;662      }
;;;663      else
;;;664      {
;;;665        *pOcfr &= ~CHOCFR_REFCE;
000424  6804              LDR      r4,[r0,#0]
000426  2508              MOVS     r5,#8
000428  43ac              BICS     r4,r4,r5
00042a  6004              STR      r4,[r0,#0]
                  |L1.1068|
;;;666      }
;;;667    }
00042c  bd30              POP      {r4,r5,pc}
;;;668    
                          ENDP

                  GPTM_ChPolarityConfig PROC
;;;683     ************************************************************************************************************/
;;;684    void GPTM_ChPolarityConfig(AM_GPTM_TypeDef* GPTMx, GPTM_CH_Enum Channel, GPTM_CHP_Enum Pol)
00042e  b570              PUSH     {r4-r6,lr}
;;;685    {
;;;686      u32 wChpolr;
;;;687    
;;;688      /* Set or reset the CHx polarity */
;;;689      wChpolr = GPTMx->CHPOLR & (~(u32)(0x1 << (Channel << 1)));
000430  6d44              LDR      r4,[r0,#0x54]
000432  004e              LSLS     r6,r1,#1
000434  2501              MOVS     r5,#1
000436  40b5              LSLS     r5,r5,r6
000438  43ac              BICS     r4,r4,r5
00043a  4623              MOV      r3,r4
;;;690      GPTMx->CHPOLR = wChpolr | (Pol << (Channel << 1));
00043c  004d              LSLS     r5,r1,#1
00043e  4614              MOV      r4,r2
000440  40ac              LSLS     r4,r4,r5
000442  431c              ORRS     r4,r4,r3
000444  6544              STR      r4,[r0,#0x54]
;;;691    }
000446  bd70              POP      {r4-r6,pc}
;;;692    
                          ENDP

                  GPTM_ImmActiveConfig PROC
;;;705     ************************************************************************************************************/
;;;706    void GPTM_ImmActiveConfig(AM_GPTM_TypeDef* GPTMx, GPTM_CH_Enum Channel, ControlStatus NewState)
000448  b530              PUSH     {r4,r5,lr}
;;;707    {
00044a  4603              MOV      r3,r0
;;;708      vu32 *pOcfr = (vu32*)&GPTMx->CH0OCFR + Channel;
00044c  008d              LSLS     r5,r1,#2
00044e  461c              MOV      r4,r3
000450  3440              ADDS     r4,r4,#0x40
000452  1928              ADDS     r0,r5,r4
;;;709    
;;;710      /* Enable or disable the channel N clear CHxOREF at ETI active function */
;;;711      if(NewState != DISABLE)
000454  2a00              CMP      r2,#0
000456  d004              BEQ      |L1.1122|
;;;712      {
;;;713        *pOcfr |= CHOCFR_IMAE;
000458  6804              LDR      r4,[r0,#0]
00045a  2520              MOVS     r5,#0x20
00045c  432c              ORRS     r4,r4,r5
00045e  6004              STR      r4,[r0,#0]
000460  e003              B        |L1.1130|
                  |L1.1122|
;;;714      }
;;;715      else
;;;716      {
;;;717        *pOcfr &= ~CHOCFR_IMAE;
000462  6804              LDR      r4,[r0,#0]
000464  2520              MOVS     r5,#0x20
000466  43ac              BICS     r4,r4,r5
000468  6004              STR      r4,[r0,#0]
                  |L1.1130|
;;;718      }
;;;719    }
00046a  bd30              POP      {r4,r5,pc}
;;;720    
                          ENDP

                  GPTM_ChannelConfig PROC
;;;732     ************************************************************************************************************/
;;;733    void GPTM_ChannelConfig(AM_GPTM_TypeDef* GPTMx, GPTM_CH_Enum Channel, GPTM_CHCTL_Enum Control)
00046c  b530              PUSH     {r4,r5,lr}
;;;734    {
;;;735      /* Reset the CHxE Bit */
;;;736      GPTMx->CHCTR &= ~(u32)(0x1 << (Channel << 1));
00046e  6d03              LDR      r3,[r0,#0x50]
000470  004d              LSLS     r5,r1,#1
000472  2401              MOVS     r4,#1
000474  40ac              LSLS     r4,r4,r5
000476  43a3              BICS     r3,r3,r4
000478  6503              STR      r3,[r0,#0x50]
;;;737    
;;;738      /* Set or reset the CHxE Bit */
;;;739      GPTMx->CHCTR |= (u32)Control << (Channel << 1);
00047a  6d03              LDR      r3,[r0,#0x50]
00047c  004d              LSLS     r5,r1,#1
00047e  4614              MOV      r4,r2
000480  40ac              LSLS     r4,r4,r5
000482  4323              ORRS     r3,r3,r4
000484  6503              STR      r3,[r0,#0x50]
;;;740    }
000486  bd30              POP      {r4,r5,pc}
;;;741    
                          ENDP

                  GPTM_OutputModeConfig PROC
;;;763     ************************************************************************************************************/
;;;764    void GPTM_OutputModeConfig(AM_GPTM_TypeDef* GPTMx, GPTM_CH_Enum Channel, u32 Mod)
000488  b570              PUSH     {r4-r6,lr}
;;;765    {
;;;766      vu32 *pOcfr = (vu32*)&GPTMx->CH0OCFR + Channel;
00048a  008d              LSLS     r5,r1,#2
00048c  4604              MOV      r4,r0
00048e  3440              ADDS     r4,r4,#0x40
000490  192b              ADDS     r3,r5,r4
;;;767    
;;;768      /* Disable the channel: Reset the CHxE Bit */
;;;769      GPTMx->CHCTR &= ~(u32)(0x1 << (Channel << 1));
000492  6d04              LDR      r4,[r0,#0x50]
000494  004e              LSLS     r6,r1,#1
000496  2501              MOVS     r5,#1
000498  40b5              LSLS     r5,r5,r6
00049a  43ac              BICS     r4,r4,r5
00049c  6504              STR      r4,[r0,#0x50]
;;;770    
;;;771      /* Selects the GPTM output mode */
;;;772      *pOcfr = (*pOcfr & CHOCFR_CHOM_MASK) | Mod;
00049e  681c              LDR      r4,[r3,#0]
0004a0  25ff              MOVS     r5,#0xff
0004a2  3508              ADDS     r5,r5,#8
0004a4  43ac              BICS     r4,r4,r5
0004a6  4314              ORRS     r4,r4,r2
0004a8  601c              STR      r4,[r3,#0]
;;;773    }
0004aa  bd70              POP      {r4-r6,pc}
;;;774    
                          ENDP

                  GPTM_UpdateCmd PROC
;;;780     ************************************************************************************************************/
;;;781    void GPTM_UpdateCmd(AM_GPTM_TypeDef* GPTMx, ControlStatus NewState)
0004ac  2900              CMP      r1,#0
;;;782    {
;;;783      if (NewState == DISABLE)
0004ae  d104              BNE      |L1.1210|
;;;784      {
;;;785        /* Set the update disable bit */
;;;786        GPTMx->CNTCFR |= CNTCFR_UEVDIS;
0004b0  6802              LDR      r2,[r0,#0]
0004b2  2301              MOVS     r3,#1
0004b4  431a              ORRS     r2,r2,r3
0004b6  6002              STR      r2,[r0,#0]
0004b8  e003              B        |L1.1218|
                  |L1.1210|
;;;787      }
;;;788      else
;;;789      {
;;;790        /* Reset the update disable bit */
;;;791        GPTMx->CNTCFR &= ~CNTCFR_UEVDIS;
0004ba  6802              LDR      r2,[r0,#0]
0004bc  0852              LSRS     r2,r2,#1
0004be  0052              LSLS     r2,r2,#1
0004c0  6002              STR      r2,[r0,#0]
                  |L1.1218|
;;;792      }
;;;793    }
0004c2  4770              BX       lr
;;;794    
                          ENDP

                  GPTM_UEVG_IntConfig PROC
;;;805     ************************************************************************************************************/
;;;806    void GPTM_UEVG_IntConfig(AM_GPTM_TypeDef* GPTMx, ControlStatus NewState)
0004c4  2900              CMP      r1,#0
;;;807    {
;;;808      if (NewState == DISABLE)
0004c6  d104              BNE      |L1.1234|
;;;809      {
;;;810        /* Set the UEVG interrupt disable bit */
;;;811        GPTMx->CNTCFR |= CNTCFR_UGDIS;
0004c8  6802              LDR      r2,[r0,#0]
0004ca  2302              MOVS     r3,#2
0004cc  431a              ORRS     r2,r2,r3
0004ce  6002              STR      r2,[r0,#0]
0004d0  e003              B        |L1.1242|
                  |L1.1234|
;;;812      }
;;;813      else
;;;814      {
;;;815        /* Reset the UEVG interrupt disable bit */
;;;816        GPTMx->CNTCFR &= ~CNTCFR_UGDIS;
0004d2  6802              LDR      r2,[r0,#0]
0004d4  2302              MOVS     r3,#2
0004d6  439a              BICS     r2,r2,r3
0004d8  6002              STR      r2,[r0,#0]
                  |L1.1242|
;;;817      }
;;;818    }
0004da  4770              BX       lr
;;;819    
                          ENDP

                  GPTM_HallInterfaceCmd PROC
;;;825     ************************************************************************************************************/
;;;826    void GPTM_HallInterfaceCmd(AM_GPTM_TypeDef* GPTMx, ControlStatus NewState)
0004dc  2900              CMP      r1,#0
;;;827    {
;;;828      if (NewState != DISABLE)
0004de  d005              BEQ      |L1.1260|
;;;829      {
;;;830        /* Set the CH0SRC Bit */
;;;831        GPTMx->CH0ICFR |= CH0ICFR_CH0SRC;
0004e0  6a02              LDR      r2,[r0,#0x20]
0004e2  2301              MOVS     r3,#1
0004e4  07db              LSLS     r3,r3,#31
0004e6  431a              ORRS     r2,r2,r3
0004e8  6202              STR      r2,[r0,#0x20]
0004ea  e003              B        |L1.1268|
                  |L1.1260|
;;;832      }
;;;833      else
;;;834      {
;;;835        /* Reset the CH0SRC Bit */
;;;836        GPTMx->CH0ICFR &= ~CH0ICFR_CH0SRC;
0004ec  6a02              LDR      r2,[r0,#0x20]
0004ee  0052              LSLS     r2,r2,#1
0004f0  0852              LSRS     r2,r2,#1
0004f2  6202              STR      r2,[r0,#0x20]
                  |L1.1268|
;;;837      }
;;;838    }
0004f4  4770              BX       lr
;;;839    
                          ENDP

                  GPTM_SinglePulseModeCmd PROC
;;;845     ************************************************************************************************************/
;;;846    void GPTM_SinglePulseModeCmd(AM_GPTM_TypeDef* GPTMx, ControlStatus NewState)
0004f6  2900              CMP      r1,#0
;;;847    {
;;;848      if(NewState != DISABLE)
0004f8  d005              BEQ      |L1.1286|
;;;849      {
;;;850        GPTMx->MDCFR |= MDCFR_SPMSET;
0004fa  6842              LDR      r2,[r0,#4]
0004fc  2301              MOVS     r3,#1
0004fe  061b              LSLS     r3,r3,#24
000500  431a              ORRS     r2,r2,r3
000502  6042              STR      r2,[r0,#4]
000504  e004              B        |L1.1296|
                  |L1.1286|
;;;851      }
;;;852      else
;;;853      {
;;;854        GPTMx->MDCFR &= ~MDCFR_SPMSET;
000506  6842              LDR      r2,[r0,#4]
000508  2301              MOVS     r3,#1
00050a  061b              LSLS     r3,r3,#24
00050c  439a              BICS     r2,r2,r3
00050e  6042              STR      r2,[r0,#4]
                  |L1.1296|
;;;855      }
;;;856    }
000510  4770              BX       lr
;;;857    
                          ENDP

                  GPTM_MMSELConfig PROC
;;;872     ************************************************************************************************************/
;;;873    void GPTM_MMSELConfig(AM_GPTM_TypeDef* GPTMx, GPTM_MMSEL_Enum Sel)
000512  6842              LDR      r2,[r0,#4]
;;;874    {
;;;875      /* Select the MTO source */
;;;876      GPTMx->MDCFR = (GPTMx->MDCFR & MDCFR_MMSEL_MASK) | Sel;
000514  2307              MOVS     r3,#7
000516  041b              LSLS     r3,r3,#16
000518  439a              BICS     r2,r2,r3
00051a  430a              ORRS     r2,r2,r1
00051c  6042              STR      r2,[r0,#4]
;;;877    }
00051e  4770              BX       lr
;;;878    
                          ENDP

                  GPTM_SlaveModeConfig PROC
;;;889     ************************************************************************************************************/
;;;890    void GPTM_SlaveModeConfig(AM_GPTM_TypeDef* GPTMx, GPTM_SMSEL_Enum Sel)
000520  6842              LDR      r2,[r0,#4]
;;;891    {
;;;892      /* Select the slave mode */
;;;893      GPTMx->MDCFR = (GPTMx->MDCFR & MDCFR_SMSEL_MASK) | Sel;
000522  2307              MOVS     r3,#7
000524  021b              LSLS     r3,r3,#8
000526  439a              BICS     r2,r2,r3
000528  430a              ORRS     r2,r2,r1
00052a  6042              STR      r2,[r0,#4]
;;;894    }
00052c  4770              BX       lr
;;;895    
                          ENDP

                  GPTM_TimSyncCmd PROC
;;;901     ************************************************************************************************************/
;;;902    void GPTM_TimSyncCmd(AM_GPTM_TypeDef* GPTMx, ControlStatus NewState)
00052e  2900              CMP      r1,#0
;;;903    {
;;;904      if (NewState != DISABLE)
000530  d004              BEQ      |L1.1340|
;;;905      {
;;;906        /* Set the TSE Bit */
;;;907        GPTMx->MDCFR |= MDCFR_TSE;
000532  6842              LDR      r2,[r0,#4]
000534  2301              MOVS     r3,#1
000536  431a              ORRS     r2,r2,r3
000538  6042              STR      r2,[r0,#4]
00053a  e003              B        |L1.1348|
                  |L1.1340|
;;;908      }
;;;909      else
;;;910      {
;;;911        /* Reset the TSE Bit */
;;;912        GPTMx->MDCFR &= ~MDCFR_TSE;
00053c  6842              LDR      r2,[r0,#4]
00053e  0852              LSRS     r2,r2,#1
000540  0052              LSLS     r2,r2,#1
000542  6042              STR      r2,[r0,#4]
                  |L1.1348|
;;;913      }
;;;914    }
000544  4770              BX       lr
;;;915    
                          ENDP

                  GPTM_SetCounter PROC
;;;921     ************************************************************************************************************/
;;;922    void GPTM_SetCounter(AM_GPTM_TypeDef* GPTMx, u16 Counter)
000546  2280              MOVS     r2,#0x80
;;;923    {
;;;924      /* Set the Counter Register value */
;;;925      GPTMx->CNTR = Counter;
000548  5011              STR      r1,[r2,r0]
;;;926    }
00054a  4770              BX       lr
;;;927    
                          ENDP

                  GPTM_SetCounterReload PROC
;;;933     ************************************************************************************************************/
;;;934    void GPTM_SetCounterReload(AM_GPTM_TypeDef* GPTMx, u16 Reload)
00054c  2288              MOVS     r2,#0x88
;;;935    {
;;;936      /* Set the counter reload register value */
;;;937      GPTMx->CRR = Reload;
00054e  5011              STR      r1,[r2,r0]
;;;938    }
000550  4770              BX       lr
;;;939    
                          ENDP

                  GPTM_SetCaptureCompare0 PROC
;;;945     ************************************************************************************************************/
;;;946    void GPTM_SetCaptureCompare0(AM_GPTM_TypeDef* GPTMx, u16 Cmp)
000552  2290              MOVS     r2,#0x90
;;;947    {
;;;948      /* Set the CH0CCR register new value */
;;;949      GPTMx->CH0CCR = Cmp;
000554  5011              STR      r1,[r2,r0]
;;;950    }
000556  4770              BX       lr
;;;951    
                          ENDP

                  GPTM_SetCaptureCompare1 PROC
;;;957     ************************************************************************************************************/
;;;958    void GPTM_SetCaptureCompare1(AM_GPTM_TypeDef* GPTMx, u16 Cmp)
000558  2294              MOVS     r2,#0x94
;;;959    {
;;;960      /* Set the CH1CCR register new value */
;;;961      GPTMx->CH1CCR = Cmp;
00055a  5011              STR      r1,[r2,r0]
;;;962    }
00055c  4770              BX       lr
;;;963    
                          ENDP

                  GPTM_SetCaptureCompare2 PROC
;;;969     ************************************************************************************************************/
;;;970    void GPTM_SetCaptureCompare2(AM_GPTM_TypeDef* GPTMx, u16 Cmp)
00055e  2298              MOVS     r2,#0x98
;;;971    {
;;;972      /* Set the CH2CCR register new value */
;;;973      GPTMx->CH2CCR = Cmp;
000560  5011              STR      r1,[r2,r0]
;;;974    }
000562  4770              BX       lr
;;;975    
                          ENDP

                  GPTM_SetCaptureCompare3 PROC
;;;981     ************************************************************************************************************/
;;;982    void GPTM_SetCaptureCompare3(AM_GPTM_TypeDef* GPTMx, u16 Cmp)
000564  229c              MOVS     r2,#0x9c
;;;983    {
;;;984      /* Set the CH3CCR register new value */
;;;985      GPTMx->CH3CCR = Cmp;
000566  5011              STR      r1,[r2,r0]
;;;986    }
000568  4770              BX       lr
;;;987    
                          ENDP

                  GPTM_SetAsymmetricCompare0 PROC
;;;993     ************************************************************************************************************/
;;;994    void GPTM_SetAsymmetricCompare0(AM_GPTM_TypeDef* GPTMx, u16 Cmp)
00056a  22a0              MOVS     r2,#0xa0
;;;995    {
;;;996      /* Set the CH0ACR register new value */
;;;997      GPTMx->CH0ACR = Cmp;
00056c  5011              STR      r1,[r2,r0]
;;;998    }
00056e  4770              BX       lr
;;;999    
                          ENDP

                  GPTM_SetAsymmetricCompare1 PROC
;;;1005    ************************************************************************************************************/
;;;1006   void GPTM_SetAsymmetricCompare1(AM_GPTM_TypeDef* GPTMx, u16 Cmp)
000570  22a4              MOVS     r2,#0xa4
;;;1007   {
;;;1008     /* Set the CH1ACR register new value */
;;;1009     GPTMx->CH1ACR = Cmp;
000572  5011              STR      r1,[r2,r0]
;;;1010   }
000574  4770              BX       lr
;;;1011   
                          ENDP

                  GPTM_SetAsymmetricCompare2 PROC
;;;1017    ************************************************************************************************************/
;;;1018   void GPTM_SetAsymmetricCompare2(AM_GPTM_TypeDef* GPTMx, u16 Cmp)
000576  22a8              MOVS     r2,#0xa8
;;;1019   {
;;;1020     /* Set the CH2ACR register new value */
;;;1021     GPTMx->CH2ACR = Cmp;
000578  5011              STR      r1,[r2,r0]
;;;1022   }
00057a  4770              BX       lr
;;;1023   
                          ENDP

                  GPTM_SetAsymmetricCompare3 PROC
;;;1029    ************************************************************************************************************/
;;;1030   void GPTM_SetAsymmetricCompare3(AM_GPTM_TypeDef* GPTMx, u16 Cmp)
00057c  22ac              MOVS     r2,#0xac
;;;1031   {
;;;1032     /* Set the CH3ACR register new value */
;;;1033     GPTMx->CH3ACR = Cmp;
00057e  5011              STR      r1,[r2,r0]
;;;1034   }
000580  4770              BX       lr
;;;1035   
                          ENDP

                  GPTM_CKDIVConfig PROC
;;;1073    ************************************************************************************************************/
;;;1074   void GPTM_CKDIVConfig(AM_GPTM_TypeDef* GPTMx, GPTM_CKDIV_Enum Div)
000582  6802              LDR      r2,[r0,#0]
;;;1075   {
;;;1076     /* Reset the CKDIV Bits */
;;;1077     GPTMx->CNTCFR &= CNTCFR_CKDIV_MASK;
000584  2303              MOVS     r3,#3
000586  021b              LSLS     r3,r3,#8
000588  439a              BICS     r2,r2,r3
00058a  6002              STR      r2,[r0,#0]
;;;1078   
;;;1079     /* Set the CKDIV value */
;;;1080     GPTMx->CNTCFR |= Div;
00058c  6802              LDR      r2,[r0,#0]
00058e  430a              ORRS     r2,r2,r1
000590  6002              STR      r2,[r0,#0]
;;;1081   }
000592  4770              BX       lr
;;;1082   
                          ENDP

                  GPTM_GetCaptureCompare0 PROC
;;;1087    ************************************************************************************************************/
;;;1088   u32 GPTM_GetCaptureCompare0(AM_GPTM_TypeDef* GPTMx)
000594  4601              MOV      r1,r0
;;;1089   {
;;;1090     /* Get the CH0CCR register value */
;;;1091     return GPTMx->CH0CCR;
000596  2090              MOVS     r0,#0x90
000598  5840              LDR      r0,[r0,r1]
;;;1092   }
00059a  4770              BX       lr
;;;1093   
                          ENDP

                  GPTM_GetCaptureCompare1 PROC
;;;1098    ************************************************************************************************************/
;;;1099   u32 GPTM_GetCaptureCompare1(AM_GPTM_TypeDef* GPTMx)
00059c  4601              MOV      r1,r0
;;;1100   {
;;;1101     /* Get the CH1CCR register value */
;;;1102     return GPTMx->CH1CCR;
00059e  2094              MOVS     r0,#0x94
0005a0  5840              LDR      r0,[r0,r1]
;;;1103   }
0005a2  4770              BX       lr
;;;1104   
                          ENDP

                  GPTM_GetCaptureCompare2 PROC
;;;1109    ************************************************************************************************************/
;;;1110   u32 GPTM_GetCaptureCompare2(AM_GPTM_TypeDef* GPTMx)
0005a4  4601              MOV      r1,r0
;;;1111   {
;;;1112     /* Get the CH2CCR register value */
;;;1113     return GPTMx->CH2CCR;
0005a6  2098              MOVS     r0,#0x98
0005a8  5840              LDR      r0,[r0,r1]
;;;1114   }
0005aa  4770              BX       lr
;;;1115   
                          ENDP

                  GPTM_GetCaptureCompare3 PROC
;;;1120    ************************************************************************************************************/
;;;1121   u32 GPTM_GetCaptureCompare3(AM_GPTM_TypeDef* GPTMx)
0005ac  4601              MOV      r1,r0
;;;1122   {
;;;1123     /* Get the CH3CCR register value */
;;;1124     return GPTMx->CH3CCR;
0005ae  209c              MOVS     r0,#0x9c
0005b0  5840              LDR      r0,[r0,r1]
;;;1125   }
0005b2  4770              BX       lr
;;;1126   
                          ENDP

                  GPTM_GetCounter PROC
;;;1131    ************************************************************************************************************/
;;;1132   u32 GPTM_GetCounter(AM_GPTM_TypeDef* GPTMx)
0005b4  4601              MOV      r1,r0
;;;1133   {
;;;1134     /* Get the Counter Register value */
;;;1135     return GPTMx->CNTR;
0005b6  2080              MOVS     r0,#0x80
0005b8  5840              LDR      r0,[r0,r1]
;;;1136   }
0005ba  4770              BX       lr
;;;1137   
                          ENDP

                  GPTM_GetPrescaler PROC
;;;1142    ************************************************************************************************************/
;;;1143   u32 GPTM_GetPrescaler(AM_GPTM_TypeDef* GPTMx)
0005bc  4601              MOV      r1,r0
;;;1144   {
;;;1145     /* Get the Prescaler Register value */
;;;1146     return GPTMx->PSCR;
0005be  2084              MOVS     r0,#0x84
0005c0  5840              LDR      r0,[r0,r1]
;;;1147   }
0005c2  4770              BX       lr
;;;1148   
                          ENDP

                  GPTM_GenerateEvent PROC
;;;1161    ************************************************************************************************************/
;;;1162   void GPTM_GenerateEvent(AM_GPTM_TypeDef* GPTMx, u32 GPTM_EVENT)
0005c4  6781              STR      r1,[r0,#0x78]
;;;1163   {
;;;1164     /* Set the event sources */
;;;1165     GPTMx->EVGR = GPTM_EVENT;
;;;1166   }
0005c6  4770              BX       lr
;;;1167   
                          ENDP

                  GPTM_GetFlagStatus PROC
;;;1184    ************************************************************************************************************/
;;;1185   FlagStatus GPTM_GetFlagStatus(AM_GPTM_TypeDef* GPTMx, u32 GPTM_FLAG)
0005c8  4602              MOV      r2,r0
;;;1186   {
;;;1187     if ((GPTMx->INTSR & GPTM_FLAG) != 0)
0005ca  6fd0              LDR      r0,[r2,#0x7c]
0005cc  4008              ANDS     r0,r0,r1
0005ce  2800              CMP      r0,#0
0005d0  d001              BEQ      |L1.1494|
;;;1188     {
;;;1189       return SET;
0005d2  2001              MOVS     r0,#1
                  |L1.1492|
;;;1190     }
;;;1191     else
;;;1192     {
;;;1193       return RESET;
;;;1194     }
;;;1195   }
0005d4  4770              BX       lr
                  |L1.1494|
0005d6  2000              MOVS     r0,#0                 ;1193
0005d8  e7fc              B        |L1.1492|
;;;1196   
                          ENDP

                  GPTM_ClearFlag PROC
;;;1213    ************************************************************************************************************/
;;;1214   void GPTM_ClearFlag(AM_GPTM_TypeDef* GPTMx, u32 GPTM_FLAG)
0005da  43ca              MVNS     r2,r1
;;;1215   {
;;;1216     /* Clear the flags */
;;;1217     GPTMx->INTSR = ~GPTM_FLAG;
0005dc  67c2              STR      r2,[r0,#0x7c]
;;;1218   
;;;1219     /*--------------------------------------------------------------------------------------------------------*/
;;;1220     /* DSB instruction is added in this function to ensure the write operation which is for clearing interrupt*/
;;;1221     /* flag is actually completed before exiting ISR. It prevents the NVIC from detecting the interrupt again */
;;;1222     /* since the write register operation may be pended in the internal write buffer of Cortex-M3 when program*/
;;;1223     /* has exited interrupt routine. This DSB instruction may be masked if this function is called in the     */
;;;1224     /* beginning of ISR and there are still some instructions before exiting ISR.                             */
;;;1225     /*--------------------------------------------------------------------------------------------------------*/
;;;1226     __DSB();
0005de  f3bf8f4f          DSB      
;;;1227   }
0005e2  4770              BX       lr
;;;1228   
                          ENDP

                  GPTM_IntConfig PROC
;;;1242    ************************************************************************************************************/
;;;1243   void GPTM_IntConfig(AM_GPTM_TypeDef* GPTMx, u32 GPTM_INT, ControlStatus NewState)
0005e4  2a00              CMP      r2,#0
;;;1244   {
;;;1245     if (NewState != DISABLE)
0005e6  d003              BEQ      |L1.1520|
;;;1246     {
;;;1247       /* Enable the interrupt sources */
;;;1248       GPTMx->DICTR |= GPTM_INT;
0005e8  6f43              LDR      r3,[r0,#0x74]
0005ea  430b              ORRS     r3,r3,r1
0005ec  6743              STR      r3,[r0,#0x74]
0005ee  e002              B        |L1.1526|
                  |L1.1520|
;;;1249     }
;;;1250     else
;;;1251     {
;;;1252       /* Disable the interrupt sources */
;;;1253       GPTMx->DICTR &= ~GPTM_INT;
0005f0  6f43              LDR      r3,[r0,#0x74]
0005f2  438b              BICS     r3,r3,r1
0005f4  6743              STR      r3,[r0,#0x74]
                  |L1.1526|
;;;1254     }
;;;1255   }
0005f6  4770              BX       lr
;;;1256   
                          ENDP

                  GPTM_GetIntStatus PROC
;;;1269    ************************************************************************************************************/
;;;1270   FlagStatus GPTM_GetIntStatus(AM_GPTM_TypeDef* GPTMx, u32 GPTM_INT)
0005f8  b510              PUSH     {r4,lr}
;;;1271   {
0005fa  4602              MOV      r2,r0
;;;1272     u32 itstatus, itenable;
;;;1273   
;;;1274     itstatus = GPTMx->INTSR & GPTM_INT;
0005fc  6fd0              LDR      r0,[r2,#0x7c]
0005fe  4008              ANDS     r0,r0,r1
000600  4603              MOV      r3,r0
;;;1275     itenable = GPTMx->DICTR & GPTM_INT;
000602  6f50              LDR      r0,[r2,#0x74]
000604  4008              ANDS     r0,r0,r1
000606  4604              MOV      r4,r0
;;;1276   
;;;1277     if ((itstatus != 0) && (itenable != 0))
000608  2b00              CMP      r3,#0
00060a  d003              BEQ      |L1.1556|
00060c  2c00              CMP      r4,#0
00060e  d001              BEQ      |L1.1556|
;;;1278     {
;;;1279       return SET;
000610  2001              MOVS     r0,#1
                  |L1.1554|
;;;1280     }
;;;1281     else
;;;1282     {
;;;1283       return RESET;
;;;1284     }
;;;1285   }
000612  bd10              POP      {r4,pc}
                  |L1.1556|
000614  2000              MOVS     r0,#0                 ;1283
000616  e7fc              B        |L1.1554|
;;;1286   
                          ENDP

                  GPTM_ClearIntPendingBit PROC
;;;1299    ************************************************************************************************************/
;;;1300   void GPTM_ClearIntPendingBit(AM_GPTM_TypeDef* GPTMx, u32 GPTM_INT)
000618  43ca              MVNS     r2,r1
;;;1301   {
;;;1302     /* Clear the interrupt pending Bit */
;;;1303     GPTMx->INTSR = ~GPTM_INT;
00061a  67c2              STR      r2,[r0,#0x7c]
;;;1304   
;;;1305     /*--------------------------------------------------------------------------------------------------------*/
;;;1306     /* DSB instruction is added in this function to ensure the write operation which is for clearing interrupt*/
;;;1307     /* flag is actually completed before exiting ISR. It prevents the NVIC from detecting the interrupt again */
;;;1308     /* since the write register operation may be pended in the internal write buffer of Cortex-M3 when program*/
;;;1309     /* has exited interrupt routine. This DSB instruction may be masked if this function is called in the     */
;;;1310     /* beginning of ISR and there are still some instructions before exiting ISR.                             */
;;;1311     /*--------------------------------------------------------------------------------------------------------*/
;;;1312     __DSB();
00061c  f3bf8f4f          DSB      
;;;1313   }
000620  4770              BX       lr
;;;1314   
                          ENDP

                  GPTM_InternalClockConfig PROC
;;;1319    ************************************************************************************************************/
;;;1320   void GPTM_InternalClockConfig(AM_GPTM_TypeDef* GPTMx)
000622  6841              LDR      r1,[r0,#4]
;;;1321   {
;;;1322     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;1323     GPTMx->MDCFR &= MDCFR_SMSEL_MASK;
000624  2207              MOVS     r2,#7
000626  0212              LSLS     r2,r2,#8
000628  4391              BICS     r1,r1,r2
00062a  6041              STR      r1,[r0,#4]
;;;1324   }
00062c  4770              BX       lr
;;;1325   
                          ENDP

                  GPTM_CHCCDSConfig PROC
;;;1331    ************************************************************************************************************/
;;;1332   void GPTM_CHCCDSConfig(AM_GPTM_TypeDef* GPTMx, GPTM_CHCCDS_Enum Selection)
00062e  2900              CMP      r1,#0
;;;1333   {
;;;1334     if(Selection != GPTM_CHCCDS_CHCCEV)
000630  d005              BEQ      |L1.1598|
;;;1335     {
;;;1336       GPTMx->CTR |= CTR_CHCCDS;
000632  6902              LDR      r2,[r0,#0x10]
000634  2301              MOVS     r3,#1
000636  041b              LSLS     r3,r3,#16
000638  431a              ORRS     r2,r2,r3
00063a  6102              STR      r2,[r0,#0x10]
00063c  e004              B        |L1.1608|
                  |L1.1598|
;;;1337     }
;;;1338     else
;;;1339     {
;;;1340       GPTMx->CTR &= ~CTR_CHCCDS;
00063e  6902              LDR      r2,[r0,#0x10]
000640  2301              MOVS     r3,#1
000642  041b              LSLS     r3,r3,#16
000644  439a              BICS     r2,r2,r3
000646  6102              STR      r2,[r0,#0x10]
                  |L1.1608|
;;;1341     }
;;;1342   }
000648  4770              BX       lr
;;;1343   
                          ENDP

                  GPTM_PDMAConfig PROC
;;;1357    ************************************************************************************************************/
;;;1358   void GPTM_PDMAConfig(AM_GPTM_TypeDef* GPTMx, u32 GPTM_PDMA, ControlStatus NewState)
00064a  2a00              CMP      r2,#0
;;;1359   {
;;;1360     if (NewState != DISABLE)
00064c  d003              BEQ      |L1.1622|
;;;1361     {
;;;1362       /* Enable the PDMA request */
;;;1363       GPTMx->DICTR |= GPTM_PDMA;
00064e  6f43              LDR      r3,[r0,#0x74]
000650  430b              ORRS     r3,r3,r1
000652  6743              STR      r3,[r0,#0x74]
000654  e002              B        |L1.1628|
                  |L1.1622|
;;;1364     }
;;;1365     else
;;;1366     {
;;;1367       /* Disable the PDMA request */
;;;1368       GPTMx->DICTR &= ~GPTM_PDMA;
000656  6f43              LDR      r3,[r0,#0x74]
000658  438b              BICS     r3,r3,r1
00065a  6743              STR      r3,[r0,#0x74]
                  |L1.1628|
;;;1369     }
;;;1370   }
00065c  4770              BX       lr
;;;1371   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\driver\\src\\gptm.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_gptm_c_e74241c1____REV16|
#line 114 "..\\inc\\core_cmInstr.h"
|__asm___6_gptm_c_e74241c1____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_gptm_c_e74241c1____REVSH|
#line 128
|__asm___6_gptm_c_e74241c1____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
