; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\remote_handle.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\remote_handle.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\driver\inc -I.\src -I.\User -I.\User\led -I.\User\usart -I.\User\timer -I.\User\ir -I.\User\2.4G -I.\User\spi0 -IF:\1708\dock\prj\RTE -I"D:\Program Files (x86)\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM0\Include" -I"D:\Program Files (x86)\Keil_v5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DARMCM0 -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\remote_handle.crf User\ir\remote_handle.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  ir_rec PROC
;;;37     
;;;38     U8 ir_rec(IR_POSITION position)
000000  b510              PUSH     {r4,lr}
;;;39     {
000002  4604              MOV      r4,r0
;;;40     
;;;41     			if( position==AM_IO_IR_REC_LEFT)
000004  2c01              CMP      r4,#1
000006  d104              BNE      |L1.18|
;;;42     			   return(GPIO_ReadInBit(AM_GPIOB,GPIO_PIN_4));
000008  2110              MOVS     r1,#0x10
00000a  48ad              LDR      r0,|L1.704|
00000c  f7fffffe          BL       GPIO_ReadInBit
                  |L1.16|
;;;43          	else if( position==AM_IO_IR_REC_RIGHT)
;;;44     			  return(GPIO_ReadInBit(AM_GPIOB,GPIO_PIN_6));
;;;45     			else if( position==AM_IO_IR_REC_BACK_LEFT)
;;;46     			  return(GPIO_ReadInBit(AM_GPIOC,GPIO_PIN_11));
;;;47     			else if( position==AM_IO_IR_REC_BACK_RIGHT)
;;;48     			  return(GPIO_ReadInBit(AM_GPIOC,GPIO_PIN_4));
;;;49       	  else if( position==AM_IO_IR_REC_MIDDLE)
;;;50     			  return(GPIO_ReadInBit(AM_GPIOB,GPIO_PIN_5));
;;;51     			else 
;;;52     				return 0;
;;;53     		
;;;54     }
000010  bd10              POP      {r4,pc}
                  |L1.18|
000012  2c03              CMP      r4,#3                 ;43
000014  d104              BNE      |L1.32|
000016  2140              MOVS     r1,#0x40              ;44
000018  48a9              LDR      r0,|L1.704|
00001a  f7fffffe          BL       GPIO_ReadInBit
00001e  e7f7              B        |L1.16|
                  |L1.32|
000020  2c00              CMP      r4,#0                 ;45
000022  d105              BNE      |L1.48|
000024  2101              MOVS     r1,#1                 ;46
000026  02c9              LSLS     r1,r1,#11             ;46
000028  48a6              LDR      r0,|L1.708|
00002a  f7fffffe          BL       GPIO_ReadInBit
00002e  e7ef              B        |L1.16|
                  |L1.48|
000030  2c04              CMP      r4,#4                 ;47
000032  d104              BNE      |L1.62|
000034  2110              MOVS     r1,#0x10              ;48
000036  48a3              LDR      r0,|L1.708|
000038  f7fffffe          BL       GPIO_ReadInBit
00003c  e7e8              B        |L1.16|
                  |L1.62|
00003e  2c02              CMP      r4,#2                 ;49
000040  d104              BNE      |L1.76|
000042  2120              MOVS     r1,#0x20              ;50
000044  489e              LDR      r0,|L1.704|
000046  f7fffffe          BL       GPIO_ReadInBit
00004a  e7e1              B        |L1.16|
                  |L1.76|
00004c  2000              MOVS     r0,#0                 ;52
00004e  e7df              B        |L1.16|
;;;55     /****************************************************************
                          ENDP

                  ir_gpio_init PROC
;;;62     ******************************************************************/
;;;63     U8 ir_gpio_init(void)
000050  b570              PUSH     {r4-r6,lr}
;;;64     {
;;;65       int ret = -1;
000052  2500              MOVS     r5,#0
000054  43ed              MVNS     r5,r5
;;;66     	int i;
;;;67       for( i=0; i<IR_DECODER_MAX; i++ )
000056  2400              MOVS     r4,#0
000058  e007              B        |L1.106|
                  |L1.90|
;;;68       {
;;;69      //   ret = gpio_request_one(ir_gpio[i],GPIO_F_DIR_IN);
;;;70         
;;;71         if(ret != -1)
00005a  1c68              ADDS     r0,r5,#1
00005c  2800              CMP      r0,#0
00005e  d103              BNE      |L1.104|
;;;72         {
;;;73           ;
;;;74         }
;;;75         else
;;;76         {
;;;77           printf("ir io not ok i=%d\r\n",i);
000060  4621              MOV      r1,r4
000062  a099              ADR      r0,|L1.712|
000064  f7fffffe          BL       __2printf
                  |L1.104|
000068  1c64              ADDS     r4,r4,#1              ;67
                  |L1.106|
00006a  2c05              CMP      r4,#5                 ;67
00006c  dbf5              BLT      |L1.90|
;;;78         }
;;;79       }  
;;;80       return 0;
00006e  2000              MOVS     r0,#0
;;;81     }
000070  bd70              POP      {r4-r6,pc}
;;;82     
                          ENDP

                  ir_rx_init PROC
;;;90     ******************************************************************/
;;;91     void ir_rx_init(void)
000072  b510              PUSH     {r4,lr}
;;;92     {
;;;93       U8 i;
;;;94       printf("ir_rx_init\r\n");
000074  a099              ADR      r0,|L1.732|
000076  f7fffffe          BL       __2printf
;;;95       memset(port_state, 0, sizeof(port_state));
00007a  2105              MOVS     r1,#5
00007c  01c9              LSLS     r1,r1,#7
00007e  489b              LDR      r0,|L1.748|
000080  f7fffffe          BL       __aeabi_memclr
;;;96       memset(write_ptr, 0, sizeof(write_ptr));
000084  2105              MOVS     r1,#5
000086  489a              LDR      r0,|L1.752|
000088  f7fffffe          BL       __aeabi_memclr
;;;97       memset(read_ptr, 0, sizeof(read_ptr));
00008c  2105              MOVS     r1,#5
00008e  4899              LDR      r0,|L1.756|
000090  f7fffffe          BL       __aeabi_memclr
;;;98       memset(data_length, 0, sizeof(data_length));
000094  2105              MOVS     r1,#5
000096  4898              LDR      r0,|L1.760|
000098  f7fffffe          BL       __aeabi_memclr
;;;99       memset(working_byte, 0, sizeof(working_byte));
00009c  2105              MOVS     r1,#5
00009e  4897              LDR      r0,|L1.764|
0000a0  f7fffffe          BL       __aeabi_memclr
;;;100      memset(capture_counter, 0, sizeof(capture_counter));
0000a4  2105              MOVS     r1,#5
0000a6  4896              LDR      r0,|L1.768|
0000a8  f7fffffe          BL       __aeabi_memclr
;;;101      ir_gpio_init();
0000ac  f7fffffe          BL       ir_gpio_init
;;;102      for(i=0;i<REMOTE_DECODER_MAX;i++)
0000b0  2400              MOVS     r4,#0
0000b2  e001              B        |L1.184|
                  |L1.180|
0000b4  1c60              ADDS     r0,r4,#1
0000b6  b2c4              UXTB     r4,r0
                  |L1.184|
0000b8  2c06              CMP      r4,#6
0000ba  dbfb              BLT      |L1.180|
;;;103      {
;;;104        //remote_decode_init(i);
;;;105        #ifdef USE_VIRTUAL_WALL
;;;106          aovw_decode_init(i);
;;;107        #endif
;;;108      }
;;;109    
;;;110      printf("ir_rx_init ok!!\r\n");
0000bc  a091              ADR      r0,|L1.772|
0000be  f7fffffe          BL       __2printf
;;;111    }
0000c2  bd10              POP      {r4,pc}
;;;112    
                          ENDP

                  ir_rx_q_put PROC
;;;121    ******************************************************************/
;;;122    void ir_rx_q_put(U8 index, U8 value)
0000c4  01c2              LSLS     r2,r0,#7
;;;123    {
;;;124      port_state[index][write_ptr[index]] = value;
0000c6  4b89              LDR      r3,|L1.748|
0000c8  18d2              ADDS     r2,r2,r3
0000ca  4b89              LDR      r3,|L1.752|
0000cc  5c1b              LDRB     r3,[r3,r0]
0000ce  54d1              STRB     r1,[r2,r3]
;;;125      write_ptr[index]++;
0000d0  4a87              LDR      r2,|L1.752|
0000d2  5c12              LDRB     r2,[r2,r0]
0000d4  1c52              ADDS     r2,r2,#1
0000d6  4b86              LDR      r3,|L1.752|
0000d8  541a              STRB     r2,[r3,r0]
;;;126      if (write_ptr[index] >= IR_QUEUE_LEN)
0000da  461a              MOV      r2,r3
0000dc  5c12              LDRB     r2,[r2,r0]
0000de  2a80              CMP      r2,#0x80
0000e0  db01              BLT      |L1.230|
;;;127      {
;;;128        write_ptr[index] = 0;
0000e2  2200              MOVS     r2,#0
0000e4  541a              STRB     r2,[r3,r0]
                  |L1.230|
;;;129      }
;;;130      data_length[index]++;
0000e6  4a84              LDR      r2,|L1.760|
0000e8  5c12              LDRB     r2,[r2,r0]
0000ea  1c52              ADDS     r2,r2,#1
0000ec  4b82              LDR      r3,|L1.760|
0000ee  541a              STRB     r2,[r3,r0]
;;;131    }
0000f0  4770              BX       lr
;;;132    
                          ENDP

                  ir_rx_q_get PROC
;;;140    ******************************************************************/
;;;141    U8 ir_rx_q_get(U8 index)
0000f2  4601              MOV      r1,r0
;;;142    {
;;;143      U8 state;
;;;144      //hal_ints_off( );
;;;145      state = port_state[index][read_ptr[index]];
0000f4  01ca              LSLS     r2,r1,#7
0000f6  4b7d              LDR      r3,|L1.748|
0000f8  18d2              ADDS     r2,r2,r3
0000fa  4b7e              LDR      r3,|L1.756|
0000fc  5c5b              LDRB     r3,[r3,r1]
0000fe  5cd0              LDRB     r0,[r2,r3]
;;;146      read_ptr[index]++;
000100  4a7c              LDR      r2,|L1.756|
000102  5c52              LDRB     r2,[r2,r1]
000104  1c52              ADDS     r2,r2,#1
000106  4b7b              LDR      r3,|L1.756|
000108  545a              STRB     r2,[r3,r1]
;;;147      if (read_ptr[index] >= IR_QUEUE_LEN)
00010a  461a              MOV      r2,r3
00010c  5c52              LDRB     r2,[r2,r1]
00010e  2a80              CMP      r2,#0x80
000110  db01              BLT      |L1.278|
;;;148      {
;;;149        read_ptr[index] = 0;
000112  2200              MOVS     r2,#0
000114  545a              STRB     r2,[r3,r1]
                  |L1.278|
;;;150      }
;;;151      data_length[index]--;
000116  4a78              LDR      r2,|L1.760|
000118  5c52              LDRB     r2,[r2,r1]
00011a  1e52              SUBS     r2,r2,#1
00011c  4b76              LDR      r3,|L1.760|
00011e  545a              STRB     r2,[r3,r1]
;;;152      //hal_ints_on( );
;;;153      
;;;154      return state;    
;;;155    }
000120  4770              BX       lr
;;;156    
                          ENDP

                  ir_rx_q_empty PROC
;;;164    ******************************************************************/
;;;165    U8 ir_rx_q_empty(U8 index)
000122  4601              MOV      r1,r0
;;;166    {
;;;167      if (data_length[index] == 0)
000124  4874              LDR      r0,|L1.760|
000126  5c40              LDRB     r0,[r0,r1]
000128  2800              CMP      r0,#0
00012a  d101              BNE      |L1.304|
;;;168      {
;;;169        return 1;
00012c  2001              MOVS     r0,#1
                  |L1.302|
;;;170      }
;;;171      else
;;;172      {
;;;173        return 0;
;;;174      }
;;;175    }
00012e  4770              BX       lr
                  |L1.304|
000130  2000              MOVS     r0,#0                 ;173
000132  e7fc              B        |L1.302|
;;;176    
                          ENDP

                  ir_rx_q_full PROC
;;;184    ******************************************************************/
;;;185    U8 ir_rx_q_full(U8 index)
000134  4601              MOV      r1,r0
;;;186    {
;;;187      if (data_length[index] == IR_QUEUE_LEN)
000136  4870              LDR      r0,|L1.760|
000138  5c40              LDRB     r0,[r0,r1]
00013a  2880              CMP      r0,#0x80
00013c  d101              BNE      |L1.322|
;;;188      {
;;;189        return 1;
00013e  2001              MOVS     r0,#1
                  |L1.320|
;;;190      }
;;;191      else
;;;192      {
;;;193        return 0;
;;;194      }
;;;195    }
000140  4770              BX       lr
                  |L1.322|
000142  2000              MOVS     r0,#0                 ;193
000144  e7fc              B        |L1.320|
;;;196    
                          ENDP

                  ir_rx_capture_4khz PROC
;;;204    ******************************************************************/
;;;205    void ir_rx_capture_4khz(void)
000146  b570              PUSH     {r4-r6,lr}
;;;206    {
;;;207      U8 index;
;;;208      U8 state;
;;;209      
;;;210      for (index=0; index<IR_DECODER_MAX; index++)
000148  2400              MOVS     r4,#0
00014a  e026              B        |L1.410|
                  |L1.332|
;;;211      {
;;;212       // printf("ir rx gpio:%x\r\n",ir_gpio[index]);
;;;213    		state = ir_rec((IR_POSITION) index);
00014c  4620              MOV      r0,r4
00014e  f7fffffe          BL       ir_rec
000152  4605              MOV      r5,r0
;;;214    		//printf("state %d\r\n",state);
;;;215        state = (~state) & 0x01;
000154  2001              MOVS     r0,#1
000156  43a8              BICS     r0,r0,r5
000158  4605              MOV      r5,r0
;;;216        working_byte[index] = (working_byte[index] << 1) | state;
00015a  4868              LDR      r0,|L1.764|
00015c  5d00              LDRB     r0,[r0,r4]
00015e  0040              LSLS     r0,r0,#1
000160  4328              ORRS     r0,r0,r5
000162  4966              LDR      r1,|L1.764|
000164  5508              STRB     r0,[r1,r4]
;;;217        capture_counter[index]++;
000166  4866              LDR      r0,|L1.768|
000168  5d00              LDRB     r0,[r0,r4]
00016a  1c40              ADDS     r0,r0,#1
00016c  4964              LDR      r1,|L1.768|
00016e  5508              STRB     r0,[r1,r4]
;;;218        if (capture_counter[index] == 8)
000170  4608              MOV      r0,r1
000172  5d00              LDRB     r0,[r0,r4]
000174  2808              CMP      r0,#8
000176  d10e              BNE      |L1.406|
;;;219        {
;;;220          if (ir_rx_q_full(index) != 1)
000178  4620              MOV      r0,r4
00017a  f7fffffe          BL       ir_rx_q_full
00017e  2801              CMP      r0,#1
000180  d009              BEQ      |L1.406|
;;;221          {
;;;222            ir_rx_q_put(index, working_byte[index]);
000182  485e              LDR      r0,|L1.764|
000184  5d01              LDRB     r1,[r0,r4]
000186  4620              MOV      r0,r4
000188  f7fffffe          BL       ir_rx_q_put
;;;223            working_byte[index] = 0;
00018c  2000              MOVS     r0,#0
00018e  495b              LDR      r1,|L1.764|
000190  5508              STRB     r0,[r1,r4]
;;;224            capture_counter[index] = 0;
000192  495b              LDR      r1,|L1.768|
000194  5508              STRB     r0,[r1,r4]
                  |L1.406|
000196  1c60              ADDS     r0,r4,#1              ;210
000198  b2c4              UXTB     r4,r0                 ;210
                  |L1.410|
00019a  2c05              CMP      r4,#5                 ;210
00019c  dbd6              BLT      |L1.332|
;;;225          }
;;;226        }
;;;227      }
;;;228    }
00019e  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP

                  ir_rx_decode PROC
;;;251    void IR_signal_tans_code(U16 data,U8 *p,U8 index);
;;;252    void ir_rx_decode(void)
0001a0  b5fe              PUSH     {r1-r7,lr}
;;;253    {
;;;254      U8 state, value;
;;;255      U8 index, i;
;;;256      int16_t result;
;;;257    	U16 sinal_temp;
;;;258      
;;;259      for (index=0; index<IR_DECODER_MAX; index++)
0001a2  2400              MOVS     r4,#0
0001a4  e04b              B        |L1.574|
                  |L1.422|
;;;260      {
;;;261        while (ir_rx_q_empty(index) != 1)
0001a6  e043              B        |L1.560|
                  |L1.424|
;;;262        { 
;;;263          value = ir_rx_q_get(index);	
0001a8  4620              MOV      r0,r4
0001aa  f7fffffe          BL       ir_rx_q_get
0001ae  4606              MOV      r6,r0
;;;264          if (value != 0x00)
;;;265          { 
;;;266            //printf("0x%x ", value);
;;;267          }
;;;268          for(i=0; i<8; i++)
0001b0  2700              MOVS     r7,#0
0001b2  e03b              B        |L1.556|
                  |L1.436|
;;;269          {	  	
;;;270            state = (value >> (7-i))&0x01; 
0001b4  2007              MOVS     r0,#7
0001b6  1bc1              SUBS     r1,r0,r7
0001b8  4630              MOV      r0,r6
0001ba  4108              ASRS     r0,r0,r1
0001bc  07c0              LSLS     r0,r0,#31
0001be  0fc0              LSRS     r0,r0,#31
0001c0  9001              STR      r0,[sp,#4]
;;;271            if (value != 0x00)
;;;272            {   
;;;273              //printf("i=%d state=%d ", i, state); 
;;;274            }
;;;275    
;;;276            //if (index == IR_POSITION_OMNI) 
;;;277            {     
;;;278            	/*遥控器和充电座的解码,如果遥控器和充电座的编码方式不一致,需要分开解释*/
;;;279              result = remote_decode_ir(index, state);
0001c2  4620              MOV      r0,r4
0001c4  9901              LDR      r1,[sp,#4]
0001c6  f7fffffe          BL       remote_decode_ir
0001ca  9000              STR      r0,[sp,#0]
;;;280              if ((result == 0)&&((remote_decode[index].rxByte&0X0fff) != 0))
0001cc  9800              LDR      r0,[sp,#0]
0001ce  2800              CMP      r0,#0
0001d0  d12a              BNE      |L1.552|
0001d2  2006              MOVS     r0,#6
0001d4  4360              MULS     r0,r4,r0
0001d6  4950              LDR      r1,|L1.792|
0001d8  1840              ADDS     r0,r0,r1
0001da  8880              LDRH     r0,[r0,#4]
0001dc  0500              LSLS     r0,r0,#20
0001de  0d00              LSRS     r0,r0,#20
0001e0  2800              CMP      r0,#0
0001e2  d021              BEQ      |L1.552|
;;;281              {
;;;282                current_ir_code = remote_decode[index].rxByte;//存放遥控器的数据
0001e4  2006              MOVS     r0,#6
0001e6  4360              MULS     r0,r4,r0
0001e8  1840              ADDS     r0,r0,r1
0001ea  8880              LDRH     r0,[r0,#4]
0001ec  494b              LDR      r1,|L1.796|
0001ee  8008              STRH     r0,[r1,#0]
;;;283    						
;;;284    						//IR_signal_tans_code(current_ir_code,(U8*)ir_signal_send,index);  //将数据放入发送数组
;;;285    						  sinal_temp =current_ir_code;
0001f0  4608              MOV      r0,r1
0001f2  8805              LDRH     r5,[r0,#0]  ; current_ir_code
;;;286    							sinal_temp&=0X0fff;
0001f4  052d              LSLS     r5,r5,#20
0001f6  0d2d              LSRS     r5,r5,#20
;;;287    							sinal_temp|=(index<<12);
0001f8  0320              LSLS     r0,r4,#12
0001fa  4328              ORRS     r0,r0,r5
0001fc  b285              UXTH     r5,r0
;;;288    							ir_signal_send[index*2]=(U8)sinal_temp;
0001fe  0061              LSLS     r1,r4,#1
000200  4a47              LDR      r2,|L1.800|
000202  5455              STRB     r5,[r2,r1]
;;;289    							ir_signal_send[index*2+1]=((U8)(sinal_temp>>8));
000204  1229              ASRS     r1,r5,#8
000206  0060              LSLS     r0,r4,#1
000208  1c40              ADDS     r0,r0,#1
00020a  5411              STRB     r1,[r2,r0]
;;;290                remote_timer  = REMOTE_DATA_KEEP_COUNT;
00020c  2014              MOVS     r0,#0x14
00020e  4945              LDR      r1,|L1.804|
000210  7008              STRB     r0,[r1,#0]
;;;291                ir_val[index] = remote_decode[index].rxByte;  //存放充电座的信号
000212  2006              MOVS     r0,#6
000214  4360              MULS     r0,r4,r0
000216  4940              LDR      r1,|L1.792|
000218  1840              ADDS     r0,r0,r1
00021a  7900              LDRB     r0,[r0,#4]
00021c  4942              LDR      r1,|L1.808|
00021e  5508              STRB     r0,[r1,r4]
;;;292                ir_val_test[index] = ir_val[index]; 
000220  4608              MOV      r0,r1
000222  5d00              LDRB     r0,[r0,r4]
000224  4941              LDR      r1,|L1.812|
000226  5508              STRB     r0,[r1,r4]
                  |L1.552|
000228  1c78              ADDS     r0,r7,#1              ;268
00022a  b2c7              UXTB     r7,r0                 ;268
                  |L1.556|
00022c  2f08              CMP      r7,#8                 ;268
00022e  dbc1              BLT      |L1.436|
                  |L1.560|
000230  4620              MOV      r0,r4                 ;261
000232  f7fffffe          BL       ir_rx_q_empty
000236  2801              CMP      r0,#1                 ;261
000238  d1b6              BNE      |L1.424|
00023a  1c60              ADDS     r0,r4,#1              ;259
00023c  b2c4              UXTB     r4,r0                 ;259
                  |L1.574|
00023e  2c05              CMP      r4,#5                 ;259
000240  dbb1              BLT      |L1.422|
;;;293               // printf("%d REC %x  %x state \r\n",((ir_signal_send[index]>>12)&0x0f),((ir_signal_send[index]>>8)),((ir_signal_send[index])&0x03));
;;;294    					 // printf("%d IR %x  \r\n",index,current_ir_code);
;;;295              #ifdef USE_VIRTUAL_WALL
;;;296              result = aovw_decode_ir(index, state);//虚拟墙解码
;;;297    		      if (result == 0)
;;;298    		      {
;;;299                ir_val[index] = AOVW_BYTE;       //检测到虚拟墙
;;;300                ir_val_test[index] = AOVW_BYTE;
;;;301    		        //printf("aovw\r\n");	                        
;;;302    		      }
;;;303    		      #endif
;;;304             }
;;;305            }
;;;306    		  }
;;;307        }
;;;308      }
;;;309    //	if((ir_signal_send[0]!=0)||(ir_signal_send[1]!=0)||(ir_signal_send[2]!=0)||\
;;;310    //		(ir_signal_send[3]!=0)||(ir_signal_send[4]!=0))
;;;311    	{
;;;312    //		for(i=0;i<10;i+=2)
;;;313    //		{
;;;314    //			//printf("%d data \r\n",ir_signal_send[index]);
;;;315    //			if(ir_signal_send[i+1]==2)
;;;316    //			printf("%d REC %x  %x  \r\n",((ir_signal_send[i+1]>>4)&0x0f),((ir_signal_send[i+1])&0x0f),((ir_signal_send[i])));
;;;317    //		}
;;;318    	 Send_Packet(W_TX_PAYLOAD_NOACK_CMD,(U8 *)ir_signal_send,sizeof(ir_signal_send));
000242  220a              MOVS     r2,#0xa
000244  4936              LDR      r1,|L1.800|
000246  20b0              MOVS     r0,#0xb0
000248  f7fffffe          BL       Send_Packet
;;;319    
;;;320    	}
;;;321    	memset((U8 *)ir_signal_send,0,sizeof(ir_signal_send));
00024c  210a              MOVS     r1,#0xa
00024e  4834              LDR      r0,|L1.800|
000250  f7fffffe          BL       __aeabi_memclr
;;;322    }
000254  bdfe              POP      {r1-r7,pc}
;;;323    
                          ENDP

                  IR_signal_tans_code PROC
;;;331    ******************************************************************/
;;;332    void IR_signal_tans_code(U16 data,U8 *p,U8 index)
000256  0500              LSLS     r0,r0,#20
;;;333    {
;;;334    	data&=0X0fff;
000258  0d00              LSRS     r0,r0,#20
;;;335    	data|=(index<<12);
00025a  0313              LSLS     r3,r2,#12
00025c  4303              ORRS     r3,r3,r0
00025e  b298              UXTH     r0,r3
;;;336    	*p=(U8)data;
000260  7008              STRB     r0,[r1,#0]
;;;337    	*(p+1)=((U8)data>>8);
000262  b2c3              UXTB     r3,r0
000264  121b              ASRS     r3,r3,#8
000266  704b              STRB     r3,[r1,#1]
;;;338    
;;;339    }
000268  4770              BX       lr
;;;340    /****************************************************************
                          ENDP

                  remote_ir_get PROC
;;;347    ******************************************************************/
;;;348    uint8_t remote_ir_get(IR_REMOT_POSITION_E index)
00026a  4601              MOV      r1,r0
;;;349    {
;;;350      uint8_t val;
;;;351      val = ir_val[index];
00026c  4a2e              LDR      r2,|L1.808|
00026e  5c50              LDRB     r0,[r2,r1]
;;;352      ir_val[index] = 0;
000270  2200              MOVS     r2,#0
000272  4b2d              LDR      r3,|L1.808|
000274  545a              STRB     r2,[r3,r1]
;;;353      return val;
;;;354    }
000276  4770              BX       lr
;;;355    
                          ENDP

                  get_ir_local PROC
;;;363    ******************************************************************/
;;;364    uint8_t get_ir_local(void)
000278  4928              LDR      r1,|L1.796|
;;;365    {
;;;366      uint8_t val;
;;;367      val = current_ir_code;
00027a  7808              LDRB     r0,[r1,#0]  ; current_ir_code
;;;368      if (remote_timer > 0)
00027c  4929              LDR      r1,|L1.804|
00027e  7809              LDRB     r1,[r1,#0]  ; remote_timer
000280  2900              CMP      r1,#0
000282  dd0a              BLE      |L1.666|
;;;369      {
;;;370        remote_timer--;
000284  4927              LDR      r1,|L1.804|
000286  7809              LDRB     r1,[r1,#0]  ; remote_timer
000288  1e49              SUBS     r1,r1,#1
00028a  4a26              LDR      r2,|L1.804|
00028c  7011              STRB     r1,[r2,#0]
;;;371        if (remote_timer == 0)
00028e  4611              MOV      r1,r2
000290  7809              LDRB     r1,[r1,#0]  ; remote_timer
000292  2900              CMP      r1,#0
000294  d101              BNE      |L1.666|
;;;372        {
;;;373          current_ir_code = 0;
000296  4a21              LDR      r2,|L1.796|
000298  8011              STRH     r1,[r2,#0]
                  |L1.666|
;;;374        } 
;;;375      }    
;;;376      return val;
;;;377    }
00029a  4770              BX       lr
;;;378    
                          ENDP

                  get_ir_test PROC
;;;386    ******************************************************************/
;;;387    uint8_t get_ir_test(IR_REMOT_POSITION_E index)
00029c  4601              MOV      r1,r0
;;;388    {
;;;389      uint8_t val;
;;;390      val = ir_val_test[index];
00029e  4a23              LDR      r2,|L1.812|
0002a0  5c50              LDRB     r0,[r2,r1]
;;;391      ir_val_test[index] = 0;
0002a2  2200              MOVS     r2,#0
0002a4  4b21              LDR      r3,|L1.812|
0002a6  545a              STRB     r2,[r3,r1]
;;;392      return val;
;;;393    }
0002a8  4770              BX       lr
;;;394    
                          ENDP

                  ir_rx_code_get PROC
;;;403    ******************************************************************/
;;;404    void ir_rx_code_get(uint8_t chan, uint8_t val)
0002aa  4a20              LDR      r2,|L1.812|
;;;405    {
;;;406        ir_val_test[chan] = val;
0002ac  5411              STRB     r1,[r2,r0]
;;;407    
;;;408        current_ir_code = val;
0002ae  4a1b              LDR      r2,|L1.796|
0002b0  8011              STRH     r1,[r2,#0]
;;;409        ir_val[chan]=val;
0002b2  4a1d              LDR      r2,|L1.808|
0002b4  5411              STRB     r1,[r2,r0]
;;;410        
;;;411       //if(chan == 1)
;;;412       //    local_ir_code = val;
;;;413    
;;;414       remote_timer = 16;
0002b6  2210              MOVS     r2,#0x10
0002b8  4b1a              LDR      r3,|L1.804|
0002ba  701a              STRB     r2,[r3,#0]
;;;415    }
0002bc  4770              BX       lr
                          ENDP

0002be  0000              DCW      0x0000
                  |L1.704|
                          DCD      0x400b2000
                  |L1.708|
                          DCD      0x400b4000
                  |L1.712|
0002c8  69722069          DCB      "ir io not ok i=%d\r\n",0
0002cc  6f206e6f
0002d0  74206f6b
0002d4  20693d25
0002d8  640d0a00
                  |L1.732|
0002dc  69725f72          DCB      "ir_rx_init\r\n",0
0002e0  785f696e
0002e4  69740d0a
0002e8  00      
0002e9  00                DCB      0
0002ea  00                DCB      0
0002eb  00                DCB      0
                  |L1.748|
                          DCD      port_state
                  |L1.752|
                          DCD      write_ptr
                  |L1.756|
                          DCD      read_ptr
                  |L1.760|
                          DCD      data_length
                  |L1.764|
                          DCD      working_byte
                  |L1.768|
                          DCD      capture_counter
                  |L1.772|
000304  69725f72          DCB      "ir_rx_init ok!!\r\n",0
000308  785f696e
00030c  6974206f
000310  6b21210d
000314  0a00    
000316  00                DCB      0
000317  00                DCB      0
                  |L1.792|
                          DCD      remote_decode
                  |L1.796|
                          DCD      current_ir_code
                  |L1.800|
                          DCD      ir_signal_send
                  |L1.804|
                          DCD      remote_timer
                  |L1.808|
                          DCD      ir_val
                  |L1.812|
                          DCD      ir_val_test

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  port_state
                          %        640
                  ir_signal_send
                          %        10

                          AREA ||.data||, DATA, ALIGN=1

                  working_byte
                          DCDU     0x00000000
000004  00                DCB      0x00
                  capture_counter
000005  000000            DCB      0x00,0x00,0x00
000008  0000              DCB      0x00,0x00
                  current_ir_code
00000a  0000              DCW      0x0000
                  remote_timer
00000c  00                DCB      0x00
                  write_ptr
00000d  000000            DCB      0x00,0x00,0x00
000010  0000              DCB      0x00,0x00
                  read_ptr
000012  0000              DCB      0x00,0x00
000014  000000            DCB      0x00,0x00,0x00
                  data_length
000017  00                DCB      0x00
                          DCDU     0x00000000
                  ir_val
00001c  00000000          DCB      0x00,0x00,0x00,0x00
000020  00                DCB      0x00
                  ir_val_test
000021  000000            DCB      0x00,0x00,0x00
000024  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "User\\ir\\remote_handle.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_remote_handle_c_83b74899____REV16|
#line 114 "..\\inc\\core_cmInstr.h"
|__asm___15_remote_handle_c_83b74899____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_remote_handle_c_83b74899____REVSH|
#line 128
|__asm___15_remote_handle_c_83b74899____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
