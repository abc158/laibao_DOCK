; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\bsp_usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\bsp_usart.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\driver\inc -I.\src -I.\User -I.\User\led -I.\User\usart -I.\User\timer -I.\User\ir -I.\User\2.4G -I.\User\spi0 -IF:\1708\dock\prj\RTE -I"D:\Program Files (x86)\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM0\Include" -I"D:\Program Files (x86)\Keil_v5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DARMCM0 -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\bsp_usart.crf User\usart\bsp_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NVIC_Configuration PROC
;;;34     
;;;35     static void NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;36     {
;;;37     	NVIC_InitTypeDef NVIC_InitStructure;
;;;38     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000002  2101              MOVS     r1,#1
000004  4668              MOV      r0,sp
000006  7081              STRB     r1,[r0,#2]
;;;39     	
;;;40     #if defined (BSP_USART0_BAUDRATE) 
;;;41     	NVIC_InitStructure.NVIC_IRQChannel = UART0_IRQn;
;;;42     	NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
;;;43     	NVIC_Init(&NVIC_InitStructure);
;;;44     #endif
;;;45     
;;;46     #if defined (BSP_USART1_BAUDRATE) 
;;;47     	NVIC_InitStructure.NVIC_IRQChannel = UART1_IRQn;
;;;48     	NVIC_InitStructure.NVIC_IRQChannelPriority = 1;
;;;49     	NVIC_Init(&NVIC_InitStructure);
;;;50     #endif	
;;;51     
;;;52     #if defined (BSP_USART2_BAUDRATE) 
;;;53     	NVIC_InitStructure.NVIC_IRQChannel = UART2_IRQn;
;;;54     	NVIC_InitStructure.NVIC_IRQChannelPriority = 2;
;;;55     	NVIC_Init(&NVIC_InitStructure);
;;;56     #endif	
;;;57     
;;;58     #if defined (BSP_USART3_BAUDRATE) 
;;;59     	NVIC_InitStructure.NVIC_IRQChannel = UART3_IRQn;  //USART3_1 禁止使用，该IO用于JTAG之SWD调试接口
;;;60     	NVIC_InitStructure.NVIC_IRQChannelPriority = 3;
;;;61     	NVIC_Init(&NVIC_InitStructure);
;;;62     #endif
;;;63     
;;;64     #if defined (BSP_USART4_BAUDRATE) 
;;;65     	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
000008  2116              MOVS     r1,#0x16
00000a  7001              STRB     r1,[r0,#0]
;;;66     	NVIC_InitStructure.NVIC_IRQChannelPriority = 3;
00000c  2103              MOVS     r1,#3
00000e  7041              STRB     r1,[r0,#1]
;;;67     	NVIC_Init(&NVIC_InitStructure);
000010  f7fffffe          BL       NVIC_Init
;;;68     #endif
;;;69     
;;;70     #if defined (BSP_USART5_BAUDRATE) 
;;;71     	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
;;;72     	NVIC_InitStructure.NVIC_IRQChannelPriority = 3;
;;;73     	NVIC_Init(&NVIC_InitStructure);
;;;74     #endif
;;;75     
;;;76     }
000014  bd08              POP      {r3,pc}
;;;77     
                          ENDP

                  USARTx_Config PROC
;;;78     void USARTx_Config(void)
000016  b50e              PUSH     {r1-r3,lr}
;;;79     {
;;;80     	USART_InitTypeDef USART_InitStructure;
;;;81     #if defined (BSP_USART0_BAUDRATE) 
;;;82     	USART_DeInit(AM_UART0);
;;;83     //AFIO_GPAConfig(AFIO_PIN_13,AFIO_MODE_4);
;;;84     //AFIO_GPAConfig(AFIO_PIN_14,AFIO_MODE_4); //USARTO_1
;;;85     	AFIO_GPCConfig(AFIO_PIN_8 ,AFIO_MODE_4);
;;;86     	AFIO_GPCConfig(AFIO_PIN_9 ,AFIO_MODE_4); //USARTO_2
;;;87     //AFIO_GPCConfig(AFIO_PIN_12,AFIO_MODE_4);
;;;88     //AFIO_GPCConfig(AFIO_PIN_13,AFIO_MODE_4); //USARTO_3
;;;89     	USART_InitStructure.USART_WordLength=BSP_USART0_WordLength;
;;;90     	USART_InitStructure.USART_Mode=BSP_USART0_Mode;
;;;91     	USART_InitStructure.USART_Parity=BSP_USART0_Parity;
;;;92     	USART_InitStructure.USART_StopBits=BSP_USART0_StopBits;
;;;93     	USART_InitStructure.USART_BaudRate=BSP_USART0_BAUDRATE;
;;;94     	USART_Init(AM_UART0,&USART_InitStructure);
;;;95     	
;;;96     	USART_IntConfig(AM_UART0,USART_IER_RDAIE,ENABLE);
;;;97     	USART_TxCmd(AM_UART0,ENABLE);
;;;98     	USART_RxCmd(AM_UART0,ENABLE);
;;;99     #endif
;;;100    #if defined (BSP_USART1_BAUDRATE) 
;;;101    	USART_DeInit(AM_UART1);
;;;102    	AFIO_GPDConfig(AFIO_PIN_6 ,AFIO_MODE_4);
;;;103    	AFIO_GPDConfig(AFIO_PIN_7 ,AFIO_MODE_4); //USART1_1
;;;104    	USART_InitStructure.USART_WordLength=BSP_USART1_WordLength;
;;;105    	USART_InitStructure.USART_Mode=BSP_USART1_Mode;
;;;106    	USART_InitStructure.USART_Parity=BSP_USART1_Parity;
;;;107    	USART_InitStructure.USART_StopBits=BSP_USART1_StopBits;
;;;108    	USART_InitStructure.USART_BaudRate=BSP_USART1_BAUDRATE;
;;;109    	USART_Init(AM_UART1,&USART_InitStructure);
;;;110    	
;;;111    	USART_IntConfig(AM_UART1,USART_IER_RDAIE,ENABLE);
;;;112    	USART_TxCmd(AM_UART1,ENABLE);
;;;113    	USART_RxCmd(AM_UART1,ENABLE);
;;;114    #endif
;;;115    #if defined (BSP_USART2_BAUDRATE) 
;;;116    	USART_DeInit(AM_UART2);
;;;117    	AFIO_GPAConfig(AFIO_PIN_3 ,AFIO_MODE_4);
;;;118    	AFIO_GPAConfig(AFIO_PIN_2 ,AFIO_MODE_4); //USART2_1
;;;119    //AFIO_GPAConfig(AFIO_PIN_5 ,AFIO_MODE_4);
;;;120    //AFIO_GPAConfig(AFIO_PIN_4 ,AFIO_MODE_4); //USART2_2
;;;121    	USART_InitStructure.USART_WordLength=BSP_USART2_WordLength;
;;;122    	USART_InitStructure.USART_Mode=BSP_USART2_Mode;
;;;123    	USART_InitStructure.USART_Parity=BSP_USART2_Parity;
;;;124    	USART_InitStructure.USART_StopBits=BSP_USART2_StopBits;
;;;125    	USART_InitStructure.USART_BaudRate=BSP_USART2_BAUDRATE;
;;;126    	USART_Init(AM_UART2,&USART_InitStructure);
;;;127    	
;;;128    	USART_IntConfig(AM_UART2,USART_IER_RDAIE,ENABLE);
;;;129    	USART_TxCmd(AM_UART2,ENABLE);
;;;130    	USART_RxCmd(AM_UART2,ENABLE);
;;;131    #endif
;;;132    #if defined (BSP_USART3_BAUDRATE) 
;;;133    	USART_DeInit(AM_UART3);//USART3_1 禁止使用，该IO用于JTAG之SWD调试接口
;;;134    	AFIO_GPBConfig(AFIO_PIN_15,AFIO_MODE_4);
;;;135    	AFIO_GPBConfig(AFIO_PIN_13,AFIO_MODE_4); //USART3_1 禁止使用，该IO用于JTAG之SWD调试接口
;;;136    	USART_InitStructure.USART_WordLength=BSP_USART3_WordLength;
;;;137    	USART_InitStructure.USART_Mode=BSP_USART3_Mode;
;;;138    	USART_InitStructure.USART_Parity=BSP_USART3_Parity;
;;;139    	USART_InitStructure.USART_StopBits=BSP_USART3_StopBits;
;;;140    	USART_InitStructure.USART_BaudRate=BSP_USART3_BAUDRATE;
;;;141    	USART_Init(AM_UART3,&USART_InitStructure);
;;;142    	
;;;143    	USART_IntConfig(AM_UART3,USART_IER_RDAIE,ENABLE);
;;;144    	USART_TxCmd(AM_UART3,ENABLE);
;;;145    	USART_RxCmd(AM_UART3,ENABLE);
;;;146    #endif
;;;147    #if defined (BSP_USART4_BAUDRATE) 
;;;148    	USART_DeInit(AM_UART4);
000018  4844              LDR      r0,|L1.300|
00001a  f7fffffe          BL       USART_DeInit
;;;149    	AFIO_GPCConfig(AFIO_PIN_6 ,AFIO_MODE_4);
00001e  2104              MOVS     r1,#4
000020  2040              MOVS     r0,#0x40
000022  f7fffffe          BL       AFIO_GPCConfig
;;;150    	AFIO_GPCConfig(AFIO_PIN_7 ,AFIO_MODE_4); //USART4_1
000026  2104              MOVS     r1,#4
000028  2080              MOVS     r0,#0x80
00002a  f7fffffe          BL       AFIO_GPCConfig
;;;151    	USART_InitStructure.USART_WordLength=BSP_USART4_WordLength;
00002e  2101              MOVS     r1,#1
000030  4668              MOV      r0,sp
000032  8081              STRH     r1,[r0,#4]
;;;152    	USART_InitStructure.USART_Mode=BSP_USART4_Mode;
000034  2100              MOVS     r1,#0
000036  8141              STRH     r1,[r0,#0xa]
;;;153    	USART_InitStructure.USART_Parity=BSP_USART4_Parity;
000038  8101              STRH     r1,[r0,#8]
;;;154    	USART_InitStructure.USART_StopBits=BSP_USART4_StopBits;
00003a  80c1              STRH     r1,[r0,#6]
;;;155    	USART_InitStructure.USART_BaudRate=BSP_USART4_BAUDRATE;
00003c  20e1              MOVS     r0,#0xe1
00003e  0240              LSLS     r0,r0,#9
000040  9000              STR      r0,[sp,#0]
;;;156    	USART_Init(AM_UART4,&USART_InitStructure);
000042  4669              MOV      r1,sp
000044  4839              LDR      r0,|L1.300|
000046  f7fffffe          BL       USART_Init
;;;157    	
;;;158    	USART_IntConfig(AM_UART4,USART_IER_RDAIE,ENABLE);
00004a  2201              MOVS     r2,#1
00004c  4611              MOV      r1,r2
00004e  4837              LDR      r0,|L1.300|
000050  f7fffffe          BL       USART_IntConfig
;;;159    	USART_TxCmd(AM_UART4,ENABLE);
000054  2101              MOVS     r1,#1
000056  4835              LDR      r0,|L1.300|
000058  f7fffffe          BL       USART_TxCmd
;;;160    	USART_RxCmd(AM_UART4,ENABLE);
00005c  2101              MOVS     r1,#1
00005e  4833              LDR      r0,|L1.300|
000060  f7fffffe          BL       USART_RxCmd
;;;161    #endif
;;;162    #if defined (BSP_USART5_BAUDRATE) 
;;;163    	USART_DeInit(AM_UART5);
;;;164    	AFIO_GPDConfig(AFIO_PIN_3 ,AFIO_MODE_4);
;;;165    	AFIO_GPDConfig(AFIO_PIN_4 ,AFIO_MODE_4); //USART5_1
;;;166    	USART_InitStructure.USART_WordLength=BSP_USART5_WordLength;
;;;167    	USART_InitStructure.USART_Mode=BSP_USART5_Mode;
;;;168    	USART_InitStructure.USART_Parity=BSP_USART5_Parity;
;;;169    	USART_InitStructure.USART_StopBits=BSP_USART5_StopBits;
;;;170    	USART_InitStructure.USART_BaudRate=BSP_USART5_BAUDRATE;
;;;171    	USART_Init(AM_UART5,&USART_InitStructure);
;;;172    	
;;;173    	USART_IntConfig(AM_UART5,USART_IER_RDAIE,ENABLE);
;;;174    	USART_TxCmd(AM_UART5,ENABLE);
;;;175    	USART_RxCmd(AM_UART5,ENABLE); 
;;;176    #endif
;;;177    	
;;;178    	NVIC_Configuration();
000064  f7fffffe          BL       NVIC_Configuration
;;;179    }
000068  bd0e              POP      {r1-r3,pc}
;;;180    
                          ENDP

                  Usart_SendByte PROC
;;;183     */
;;;184    void Usart_SendByte( AM_USART_TypeDef * pBSP_USART, uint8_t ch)
00006a  b570              PUSH     {r4-r6,lr}
;;;185    {
00006c  4604              MOV      r4,r0
00006e  460d              MOV      r5,r1
;;;186    	USART_SendData(pBSP_USART,ch);  //发送一个字节数据到USART
000070  4629              MOV      r1,r5
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       USART_SendData
;;;187    	while (USART_GetLineStatus(pBSP_USART, USART_LSR_TE) == RESET);  	//等待发送数据寄存器为空
000078  bf00              NOP      
                  |L1.122|
00007a  2140              MOVS     r1,#0x40
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       USART_GetLineStatus
000082  2800              CMP      r0,#0
000084  d0f9              BEQ      |L1.122|
;;;188    }
000086  bd70              POP      {r4-r6,pc}
;;;189    
                          ENDP

                  Usart_SendHalfWord PROC
;;;192     */
;;;193    void Usart_SendHalfWord( AM_USART_TypeDef * pBSP_USART, uint16_t ch)
000088  b5f8              PUSH     {r3-r7,lr}
;;;194    {
00008a  4605              MOV      r5,r0
00008c  460c              MOV      r4,r1
;;;195    	uint8_t temp_h, temp_l;
;;;196    	temp_h = (ch&0XFF00)>>8;  //取出高八位
00008e  20ff              MOVS     r0,#0xff
000090  0200              LSLS     r0,r0,#8
000092  4020              ANDS     r0,r0,r4
000094  1206              ASRS     r6,r0,#8
;;;197    	temp_l = ch&0XFF;  				//取出低八位
000096  b2e7              UXTB     r7,r4
;;;198    
;;;199    	USART_SendData(pBSP_USART,temp_h);	  //发送高八位
000098  4631              MOV      r1,r6
00009a  4628              MOV      r0,r5
00009c  f7fffffe          BL       USART_SendData
;;;200    	while (USART_GetLineStatus(pBSP_USART, USART_LSR_TE) == RESET);  	//等待高八位发送完成
0000a0  bf00              NOP      
                  |L1.162|
0000a2  2140              MOVS     r1,#0x40
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       USART_GetLineStatus
0000aa  2800              CMP      r0,#0
0000ac  d0f9              BEQ      |L1.162|
;;;201    
;;;202    	USART_SendData(pBSP_USART,temp_l);	  //发送低八位
0000ae  4639              MOV      r1,r7
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       USART_SendData
;;;203    	while (USART_GetLineStatus(pBSP_USART, USART_LSR_TE) == RESET);		//等待低八位发送完成
0000b6  bf00              NOP      
                  |L1.184|
0000b8  2140              MOVS     r1,#0x40
0000ba  4628              MOV      r0,r5
0000bc  f7fffffe          BL       USART_GetLineStatus
0000c0  2800              CMP      r0,#0
0000c2  d0f9              BEQ      |L1.184|
;;;204    }
0000c4  bdf8              POP      {r3-r7,pc}
;;;205    
                          ENDP

                  Usart_SendString PROC
;;;208     */
;;;209    void Usart_SendString( AM_USART_TypeDef * pBSP_USART, char *str)
0000c6  b570              PUSH     {r4-r6,lr}
;;;210    {
0000c8  4606              MOV      r6,r0
0000ca  460c              MOV      r4,r1
;;;211    	unsigned int k=0;
0000cc  2500              MOVS     r5,#0
;;;212    	do 
0000ce  bf00              NOP      
                  |L1.208|
;;;213    	{
;;;214    		Usart_SendByte( pBSP_USART,*(str + k));
0000d0  5d61              LDRB     r1,[r4,r5]
0000d2  4630              MOV      r0,r6
0000d4  f7fffffe          BL       Usart_SendByte
;;;215    		k++;
0000d8  1c6d              ADDS     r5,r5,#1
;;;216    	}while(*(str + k)!='\0');
0000da  5d60              LDRB     r0,[r4,r5]
0000dc  2800              CMP      r0,#0
0000de  d1f7              BNE      |L1.208|
;;;217    	while (USART_GetLineStatus(pBSP_USART, USART_LSR_TE) == RESET);	  //等待发送完成
0000e0  bf00              NOP      
                  |L1.226|
0000e2  2140              MOVS     r1,#0x40
0000e4  4630              MOV      r0,r6
0000e6  f7fffffe          BL       USART_GetLineStatus
0000ea  2800              CMP      r0,#0
0000ec  d0f9              BEQ      |L1.226|
;;;218    }
0000ee  bd70              POP      {r4-r6,pc}
;;;219    
                          ENDP

                  fputc PROC
;;;222     */
;;;223    int fputc(int ch, FILE *f)
0000f0  b570              PUSH     {r4-r6,lr}
;;;224    {
0000f2  4604              MOV      r4,r0
0000f4  460d              MOV      r5,r1
;;;225    	USART_SendData(USART_Debug, (uint8_t) ch);  //发送一个字节数据到串口
0000f6  b2e1              UXTB     r1,r4
0000f8  480c              LDR      r0,|L1.300|
0000fa  f7fffffe          BL       USART_SendData
;;;226    	while (USART_GetLineStatus(USART_Debug, USART_LSR_TE) == RESET);  //等待发送完毕
0000fe  bf00              NOP      
                  |L1.256|
000100  2140              MOVS     r1,#0x40
000102  480a              LDR      r0,|L1.300|
000104  f7fffffe          BL       USART_GetLineStatus
000108  2800              CMP      r0,#0
00010a  d0f9              BEQ      |L1.256|
;;;227    	return (ch);
00010c  4620              MOV      r0,r4
;;;228    }
00010e  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP

                  fgetc PROC
;;;232     */
;;;233    int fgetc(FILE *f)
000110  b510              PUSH     {r4,lr}
;;;234    {
000112  4604              MOV      r4,r0
;;;235    		while (USART_GetLineStatus(USART_Debug, USART_LSR_RFDR) == RESET); //等待串口输入数据
000114  bf00              NOP      
                  |L1.278|
000116  2101              MOVS     r1,#1
000118  4804              LDR      r0,|L1.300|
00011a  f7fffffe          BL       USART_GetLineStatus
00011e  2800              CMP      r0,#0
000120  d0f9              BEQ      |L1.278|
;;;236    		return (int)USART_ReceiveData(USART_Debug);
000122  4802              LDR      r0,|L1.300|
000124  f7fffffe          BL       USART_ReceiveData
;;;237    }
000128  bd10              POP      {r4,pc}
;;;238    
                          ENDP

00012a  0000              DCW      0x0000
                  |L1.300|
                          DCD      0x40002000

;*** Start embedded assembler ***

#line 1 "User\\usart\\bsp_usart.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_usart_c_1d6152ae____REV16|
#line 114 "..\\inc\\core_cmInstr.h"
|__asm___11_bsp_usart_c_1d6152ae____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_usart_c_1d6152ae____REVSH|
#line 128
|__asm___11_bsp_usart_c_1d6152ae____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
