; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\can.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\can.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\driver\inc -I.\src -I.\User -I.\User\led -I.\User\usart -I.\User\timer -I.\User\ir -I.\User\2.4G -I.\User\spi0 -IF:\1708\dock\prj\RTE -I"D:\Program Files (x86)\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM0\Include" -I"D:\Program Files (x86)\Keil_v5\ARM\CMSIS\Include" -D__MICROLIB -D__UVISION_VERSION=514 -DARMCM0 -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\can.crf ..\driver\src\can.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;18       ************************************************************************************************************/
;;;19     void CAN_DeInit(AM_CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;20     {
000002  4604              MOV      r4,r0
;;;21     	if (CANx == AM_CAN)
000004  4843              LDR      r0,|L1.276|
000006  4284              CMP      r4,r0
000008  d104              BNE      |L1.20|
;;;22     		RSTCU_AHBPeripReset(RSTCU_AHBRST_CAN, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  03c8              LSLS     r0,r1,#15
00000e  f7fffffe          BL       RSTCU_AHBPeripReset
000012  e003              B        |L1.28|
                  |L1.20|
;;;23     	else
;;;24     		RSTCU_AHBPeripReset(RSTCU_AHBRST_CAN1, ENABLE);
000014  2101              MOVS     r1,#1
000016  0388              LSLS     r0,r1,#14
000018  f7fffffe          BL       RSTCU_AHBPeripReset
                  |L1.28|
;;;25     }
00001c  bd10              POP      {r4,pc}
;;;26     
                          ENDP

                  CAN_ModeCmd PROC
;;;36       ************************************************************************************************************/
;;;37     void CAN_ModeCmd(AM_CAN_TypeDef* CANx, u8 Mode, ControlStatus NewState)
00001e  2a00              CMP      r2,#0
;;;38     {
;;;39       if (NewState != DISABLE)
000020  d003              BEQ      |L1.42|
;;;40       {
;;;41         CANx->MOD |= Mode;
000022  6803              LDR      r3,[r0,#0]
000024  430b              ORRS     r3,r3,r1
000026  6003              STR      r3,[r0,#0]
000028  e002              B        |L1.48|
                  |L1.42|
;;;42       }
;;;43       else
;;;44       {
;;;45         CANx->MOD &= (~Mode);
00002a  6803              LDR      r3,[r0,#0]
00002c  438b              BICS     r3,r3,r1
00002e  6003              STR      r3,[r0,#0]
                  |L1.48|
;;;46       }
;;;47     }
000030  4770              BX       lr
;;;48     
                          ENDP

                  CAN_Cmd PROC
;;;56       ************************************************************************************************************/
;;;57     void CAN_Cmd(AM_CAN_TypeDef* CANx, u8 Cmd)
000032  6842              LDR      r2,[r0,#4]
;;;58     {
;;;59       CANx->CMR |= Cmd;
000034  430a              ORRS     r2,r2,r1
000036  6042              STR      r2,[r0,#4]
;;;60     }
000038  4770              BX       lr
;;;61     
                          ENDP

                  CAN_IntCmd PROC
;;;72       ************************************************************************************************************/
;;;73     void CAN_IntCmd(AM_CAN_TypeDef* CANx, u8 Int, ControlStatus NewState)
00003a  2a00              CMP      r2,#0
;;;74     {
;;;75       if (NewState != DISABLE)
00003c  d003              BEQ      |L1.70|
;;;76       {
;;;77         CANx->IER |= Int;
00003e  6903              LDR      r3,[r0,#0x10]
000040  430b              ORRS     r3,r3,r1
000042  6103              STR      r3,[r0,#0x10]
000044  e002              B        |L1.76|
                  |L1.70|
;;;78       }
;;;79       else
;;;80       {
;;;81         CANx->IER &= (~Int);
000046  6903              LDR      r3,[r0,#0x10]
000048  438b              BICS     r3,r3,r1
00004a  6103              STR      r3,[r0,#0x10]
                  |L1.76|
;;;82       }
;;;83     }
00004c  4770              BX       lr
;;;84     
                          ENDP

                  CAN_GetIntStatus PROC
;;;94       ************************************************************************************************************/
;;;95     u8 CAN_GetIntStatus(AM_CAN_TypeDef* CANx, u8 Int)
00004e  4602              MOV      r2,r0
;;;96     {
;;;97       return (CANx->IR & Int);
000050  68d0              LDR      r0,[r2,#0xc]
000052  4008              ANDS     r0,r0,r1
;;;98     }
000054  4770              BX       lr
;;;99     
                          ENDP

                  CAN_GetStatus PROC
;;;108      ************************************************************************************************************/
;;;109    u8 CAN_GetStatus(AM_CAN_TypeDef* CANx, u8 Sta)
000056  4602              MOV      r2,r0
;;;110    {
;;;111      return (CANx->SR & Sta);
000058  6890              LDR      r0,[r2,#8]
00005a  4008              ANDS     r0,r0,r1
;;;112    }
00005c  4770              BX       lr
;;;113    
                          ENDP

                  CAN_SetBusTiming PROC
;;;124      ************************************************************************************************************/
;;;125    void CAN_SetBusTiming(AM_CAN_TypeDef* CANx, u8 BaudRatePSC, u8 TSEG1, u8 TSEG2)
00005e  b570              PUSH     {r4-r6,lr}
;;;126    {
;;;127      CANx->BTR0 = (1<<6) | (BaudRatePSC&0x3f);
000060  068c              LSLS     r4,r1,#26
000062  0ea4              LSRS     r4,r4,#26
000064  2540              MOVS     r5,#0x40
000066  432c              ORRS     r4,r4,r5
000068  6184              STR      r4,[r0,#0x18]
;;;128    	CANx->BTR1 = (1<<7) | ((TSEG1<<0)&0x0f) | ((TSEG2<<4)&0x70);
00006a  0714              LSLS     r4,r2,#28
00006c  0f24              LSRS     r4,r4,#28
00006e  2580              MOVS     r5,#0x80
000070  432c              ORRS     r4,r4,r5
000072  011d              LSLS     r5,r3,#4
000074  2670              MOVS     r6,#0x70
000076  4035              ANDS     r5,r5,r6
000078  432c              ORRS     r4,r4,r5
00007a  61c4              STR      r4,[r0,#0x1c]
;;;129    }
00007c  bd70              POP      {r4-r6,pc}
;;;130    
                          ENDP

                  CAN_SetErrWarnLmt PROC
;;;137      ************************************************************************************************************/
;;;138    void CAN_SetErrWarnLmt(AM_CAN_TypeDef* CANx, u8 ErrWarnLmt)
00007e  6341              STR      r1,[r0,#0x34]
;;;139    {
;;;140      CANx->EWLR = ErrWarnLmt;
;;;141    }
000080  4770              BX       lr
;;;142    
                          ENDP

                  CAN_SetErrCnt PROC
;;;149      ************************************************************************************************************/
;;;150    void CAN_SetErrCnt(AM_CAN_TypeDef* CANx, ErrCntType ErrCnt_type, u8 ErrCnt)
000082  2900              CMP      r1,#0
;;;151    {
;;;152    	if(ErrCnt_type == ErrRcvCnt)
000084  d101              BNE      |L1.138|
;;;153    		CANx->RXERR = ErrCnt;
000086  6382              STR      r2,[r0,#0x38]
000088  e002              B        |L1.144|
                  |L1.138|
;;;154    	else if(ErrCnt_type == ErrTranCnt)
00008a  2901              CMP      r1,#1
00008c  d100              BNE      |L1.144|
;;;155    		CANx->TXERR = ErrCnt;
00008e  63c2              STR      r2,[r0,#0x3c]
                  |L1.144|
;;;156    }
000090  4770              BX       lr
;;;157    
                          ENDP

                  CAN_GetErrWarnLmt PROC
;;;162      ************************************************************************************************************/
;;;163    u8 CAN_GetErrWarnLmt(AM_CAN_TypeDef* CANx)
000092  4601              MOV      r1,r0
;;;164    {
;;;165      return CANx->EWLR;
000094  6b48              LDR      r0,[r1,#0x34]
000096  b2c0              UXTB     r0,r0
;;;166    }
000098  4770              BX       lr
;;;167    
                          ENDP

                  CAN_GetErrCnt PROC
;;;174      ************************************************************************************************************/
;;;175    u8 CAN_GetErrCnt(AM_CAN_TypeDef* CANx, ErrCntType ErrCnt_type)
00009a  4602              MOV      r2,r0
;;;176    {
;;;177    	if(ErrCnt_type == ErrRcvCnt)
00009c  2900              CMP      r1,#0
00009e  d102              BNE      |L1.166|
;;;178    		return CANx->RXERR;
0000a0  6b90              LDR      r0,[r2,#0x38]
0000a2  b2c0              UXTB     r0,r0
                  |L1.164|
;;;179    	else
;;;180    		return CANx->TXERR;
;;;181    }
0000a4  4770              BX       lr
                  |L1.166|
0000a6  6bd0              LDR      r0,[r2,#0x3c]         ;180
0000a8  b2c0              UXTB     r0,r0                 ;180
0000aa  e7fb              B        |L1.164|
;;;182    
                          ENDP

                  CAN_SetFrameArbtCtrl PROC
;;;193      ************************************************************************************************************/
;;;194    void CAN_SetFrameArbtCtrl(AM_CAN_TypeDef* CANx, u8 FF, u8 RTR, u8 DLC)
0000ac  b530              PUSH     {r4,r5,lr}
;;;195    {
;;;196    	CANx->TRFDI_ACAMR[0] = (CANx->TRFDI_ACAMR[0]&0x00) | FF | RTR | (DLC&0x0f);
0000ae  6c04              LDR      r4,[r0,#0x40]
0000b0  460c              MOV      r4,r1
0000b2  4314              ORRS     r4,r4,r2
0000b4  071d              LSLS     r5,r3,#28
0000b6  0f2d              LSRS     r5,r5,#28
0000b8  432c              ORRS     r4,r4,r5
0000ba  6404              STR      r4,[r0,#0x40]
;;;197    }
0000bc  bd30              POP      {r4,r5,pc}
;;;198    
                          ENDP

                  CAN_GetFF PROC
;;;203      ************************************************************************************************************/
;;;204    u8 CAN_GetFF(AM_CAN_TypeDef* CANx)
0000be  4601              MOV      r1,r0
;;;205    {
;;;206    	return (CANx->TRFDI_ACAMR[0] & (1<<7));
0000c0  6c08              LDR      r0,[r1,#0x40]
0000c2  2280              MOVS     r2,#0x80
0000c4  4010              ANDS     r0,r0,r2
;;;207    }
0000c6  4770              BX       lr
;;;208    
                          ENDP

                  CAN_GetRTR PROC
;;;213      ************************************************************************************************************/
;;;214    u8 CAN_GetRTR(AM_CAN_TypeDef* CANx)
0000c8  4601              MOV      r1,r0
;;;215    {
;;;216    	return (CANx->TRFDI_ACAMR[0] & (1<<6));
0000ca  6c08              LDR      r0,[r1,#0x40]
0000cc  2240              MOVS     r2,#0x40
0000ce  4010              ANDS     r0,r0,r2
;;;217    }
0000d0  4770              BX       lr
;;;218    
                          ENDP

                  CAN_GetDLC PROC
;;;223      ************************************************************************************************************/
;;;224    u8 CAN_GetDLC(AM_CAN_TypeDef* CANx)
0000d2  4601              MOV      r1,r0
;;;225    {
;;;226    	return (CANx->TRFDI_ACAMR[0] & 0x0f);
0000d4  6c08              LDR      r0,[r1,#0x40]
0000d6  0700              LSLS     r0,r0,#28
0000d8  0f00              LSRS     r0,r0,#28
;;;227    }
0000da  4770              BX       lr
;;;228    
                          ENDP

                  CAN_Tran PROC
;;;235      ************************************************************************************************************/
;;;236    void CAN_Tran(AM_CAN_TypeDef* CANx, u8 *pBuf, u8 Len)
0000dc  b570              PUSH     {r4-r6,lr}
;;;237    {
0000de  4603              MOV      r3,r0
;;;238    	u8 i;
;;;239    	for(i=0;i<Len;i++)
0000e0  2000              MOVS     r0,#0
0000e2  e006              B        |L1.242|
                  |L1.228|
;;;240    	{
;;;241    		CANx->TRFDI_ACAMR[0+i] = *(pBuf+i); 
0000e4  5c0c              LDRB     r4,[r1,r0]
0000e6  0086              LSLS     r6,r0,#2
0000e8  461d              MOV      r5,r3
0000ea  3540              ADDS     r5,r5,#0x40
0000ec  51ac              STR      r4,[r5,r6]
0000ee  1c44              ADDS     r4,r0,#1              ;239
0000f0  b2e0              UXTB     r0,r4                 ;239
                  |L1.242|
0000f2  4290              CMP      r0,r2                 ;239
0000f4  dbf6              BLT      |L1.228|
;;;242    	}
;;;243    }
0000f6  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP

                  CAN_Rcv PROC
;;;251      ************************************************************************************************************/
;;;252    void CAN_Rcv(AM_CAN_TypeDef* CANx, u8 *pBuf, u8 Len)
0000f8  b530              PUSH     {r4,r5,lr}
;;;253    {
0000fa  4603              MOV      r3,r0
;;;254    	u8 i;
;;;255    	for(i=0;i<Len;i++)
0000fc  2000              MOVS     r0,#0
0000fe  e006              B        |L1.270|
                  |L1.256|
;;;256    	{
;;;257    	  *(pBuf+i) = CANx->TRFDI_ACAMR[0+i]; 
000100  0085              LSLS     r5,r0,#2
000102  461c              MOV      r4,r3
000104  3440              ADDS     r4,r4,#0x40
000106  5964              LDR      r4,[r4,r5]
000108  540c              STRB     r4,[r1,r0]
00010a  1c44              ADDS     r4,r0,#1              ;255
00010c  b2e0              UXTB     r0,r4                 ;255
                  |L1.270|
00010e  4290              CMP      r0,r2                 ;255
000110  dbf6              BLT      |L1.256|
;;;258    	}
;;;259    }
000112  bd30              POP      {r4,r5,pc}
;;;260    /**
                          ENDP

                  |L1.276|
                          DCD      0x40098000

;*** Start embedded assembler ***

#line 1 "..\\driver\\src\\can.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_347dae01____REV16|
#line 114 "..\\inc\\core_cmInstr.h"
|__asm___5_can_c_347dae01____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_347dae01____REVSH|
#line 128
|__asm___5_can_c_347dae01____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
